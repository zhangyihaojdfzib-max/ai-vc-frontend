---
title: AI/BI仪表板性能优化十大最佳实践（上）
title_original: The Top 10 Best Practices for AI/BI Dashboards Performance Optimization
  (Part 1)
date: '2026-02-04'
source: Databricks Blog
source_url: https://www.databricks.com/blog/top-10-best-practices-aibi-dashboards-performance-optimization-part-1
author: ''
summary: 本文针对Databricks AI/BI仪表板性能优化提出整体性方法，强调性能问题通常是仪表板设计、仓库并发与缓存、湖仓数据布局共同作用的结果。文章首先解析了从浏览器到湖仓的端到端刷新链路，并指出优化前需明确目标与理解数据。第一部分核心实践是建议将仪表板组织为分页（标签页），通过按用户意图分组可视化组件，限制查询仅在当前活动页面执行，从而有效降低并发峰值、减少队头阻塞并提高缓存命中率，实现性能与成本的优化。
categories:
- AI产品
tags:
- AI/BI仪表板
- 性能优化
- Databricks
- 数据可视化
- 查询优化
draft: false
translated_at: '2026-02-05T04:18:25.023216'
---

仪表板性能问题很少由单一原因导致。它们通常是**仪表板设计**、**仓库并发与缓存**以及**湖仓数据布局**共同作用的结果。如果只优化某一层——无论是SQL、计算资源配置还是表结构——通常只能获得部分改善，但在实际使用中仪表板仍可能感觉缓慢或表现不稳定。

本文采用**整体性方法**探讨Databricks AI/BI性能。我们将端到端追踪仪表板交互的完整链路：从浏览器和AI/BI编排层开始，经过Databricks SQL的查询准入与缓存机制，最终抵达湖仓中的文件扫描与数据跳过环节。在此过程中，我们将重点解析最常引发延迟尖峰、排队现象和大规模成本问题的模式——尤其是在多用户并发访问同一仪表板时。

## AI/BI仪表板刷新的运作机制

![AI/BI仪表板刷新的运作机制](/images/posts/4d3be8c7edfd.png)

要优化性能，首先需要理解一次点击在技术栈中的完整旅程。当用户打开仪表板或更改筛选条件时，会在多个层级引发连锁反应。任何层级的配置不当都会让用户感知到延迟。

- **浏览器（客户端）**：这是第一道防线。对于行数低于10万且体积小于100MB的数据集，浏览器可作为本地引擎，在内存中即时处理字段筛选和跨图表交互。若数据超出此阈值，每次交互都必须回传至数据仓库。
- **仪表板设计（编排层）**：AI/BI服务决定需要触发哪些查询。"单页式"设计会同时发送所有组件的查询，造成巨大的并发峰值；而"多页式"设计仅请求当前可见标签页的数据，从而有效控制计算资源的需求形态。
- **Databricks SQL（引擎层）**：SQL仓库（理想情况下采用Serverless模式）接收突发请求。它会检查**缓存**（包含多层缓存）确认是否已有现成结果。若未命中，智能工作负载管理（IWM）将准入查询，并在数秒内自动扩展集群以处理负载，避免排队。
- **湖仓（存储层）**：最终引擎层访问数据。它会扫描云对象存储中的Delta文件。此时，Liquid Clustering技术和数据类型决定了I/O效率。目标是通过文件级统计信息和元数据尽可能跳过无关数据，将结果集沿链路向上返回。

通过优化这四个关键接触点，您将从蛮力计算转向流线型架构，实现随用户规模扩展的性能提升。

## 前提条件——理解数据与仪表板

在开始优化前，必须首先明确优化目标。仪表板性能并非单一概念，只有与清晰目标挂钩的改进才有意义。常见目标包括：缩短首次可视化时间、改善交互延迟、保持高并发下的性能稳定、降低单次仪表板查看成本。

目标明确后，需要理解影响目标的关键参数。这些参数包括：数据规模与增长趋势、用户数量及其访问模式、查询的实际行为特征（页面加载时触发多少查询、扫描多少数据、结果是否被复用或持续重算）。缺乏这些背景信息，优化将变成盲目猜测，往往只是将成本或延迟问题在不同层级间转移。

因此，有效的仪表板优化需要系统性规划：选择可衡量的目标，理解影响目标的数据和使用模式，再实施后续技术优化方案。

### 优化方案#1：将仪表板组织为分页（标签页）

每个可见组件都是潜在触发器：它们在首次加载时运行，并可能在筛选器/参数变更、刷新或用户返回页面时重新执行。标签页能将重执行限制在当前活动页面，减少突发请求和队头阻塞。

AI/BI仪表板支持构建**多页报表**。将可视化组件按用户意图分组（概览→分析→深度挖掘），确保仅当前页面执行查询。这能降低队头阻塞，将并发请求整形为更小的突发峰值，并提高确定性查询的缓存命中率。

推荐页面类型：

- **概览页**：用于快速呈现的计数器和趋势线，避免在首页使用重度连接/窗口函数。
- **分析页**：聚焦实体的探索页面（客户/产品/区域），当需要预聚合缩减时，使用能将谓词下推至SQL的筛选器（参数）。
- **深度挖掘页**：依赖计划刷新或物化视图/指标视图的高成本聚合页面（可将仪表板数据集导出为物化视图）。

优先采用确定性组件（避免NOW()函数）以最大化**结果缓存**命中率，监控**峰值排队查询数**，若持续大于0则增加集群规模或最大集群数。

AI/BI仪表板的钻取功能支持从高层级可视化导航至详情页，同时保留选中上下文。通过延迟执行高成本查询直至用户意图明确，这是实施分页设计的有效策略，既能提升首次渲染性能，又能减少不必要的并发峰值。

**技术说明——为何这对所有仓库类型均有效**：更小、可预测的突发请求使Serverless IWM能快速响应并避免过度扩展，同时防止Pro/Classic型仓库在页面加载期间耗尽集群槽位。

更多详情请参阅：https://www.databricks.com/blog/whats-new-in-aibi-dashboards-fall24

## 优化方案#2：通过智能默认值优化"首次渲染"

仪表板的第一印象由**首次渲染**时间决定——即从打开仪表板到看到有意义结果所需的时间。默认筛选值在此起着关键作用，因为它们决定了**页面加载时立即运行哪些查询**以及这些查询需要处理多少数据。

当筛选器未设置默认值时，AI/BI仪表板通常会在首次打开时加载**完整**数据集。这会最大化扫描量，增加跨组件的查询扩散，延迟用户获得有效洞察的时间。结果是缓慢且不可预测的首次体验——在高峰并发期多用户同时打开同一仪表板时尤为严重。

智能默认值通过**约束初始查询形态**解决此问题。常见示例如下：

- 将日期筛选器默认设为近期窗口（例如最近7天或30天）。
- 预选常见区域、业务单元或顶层实体。
- 选择仍有选择性的合理"全部"选项（例如当前财年而非全部历史记录）。

从技术角度看，默认筛选器能减少数据扫描量，提高缓存命中率，并允许在相同初始状态下打开仪表板的用户间复用结果。这直接改善了首次可视化时间，使性能表现更加稳定。

关键设计原则很简单：为着陆体验优化。让首次渲染既快速又信息丰富，然后允许用户在探索过程中有意识地扩大范围。快速的首次渲染能建立信任、促进采用，并为后续所有交互设定性能基线。

更多详情请参阅：https://docs.databricks.com/aws/en/dashboards/filters#-set-default-filter-values

## 优化方案#3：使用参数切分大型数据集

参数是扩展AI/BI仪表板最有效的方式之一，因为它们能在查询**运行前**重塑其形态。通过将值直接注入SQL，参数能提前下推谓词——使Databricks能更早裁剪数据，大幅减少单次查询工作量（理想情况下在连接和聚合前完成筛选）。

字段筛选器的行为有所不同。如果底层数据集足够小，可以缓存在浏览器中（≤ 10万行且 ≤ 100MB），字段筛选器和交叉筛选交互可以在客户端进行评估，无需往返数据仓库。一旦数据集超过该阈值，字段筛选器通常会通过包装数据集查询（通常通过CTE）推送到数据仓库，这会触发后端SQL执行，并且在减少扫描成本方面可能不如在连接和聚合之前应用的参数化谓词有效。

参数在按日期范围、区域、业务单元或其他能显著减少数据量的维度进行切片时尤其有效。它们还能使性能更具可预测性：每个图块执行成本更低的查询，数据仓库也更容易应对并发峰值。

但这需要权衡。由于不同的参数值会产生不同的查询签名，当用户不断选择唯一值时，缓存重用率可能会降低。在实践中，这通常是正确的折衷方案：一个未命中缓存的小型廉价查询，远比一个依赖缓存才能运行的大型昂贵查询要好得多。您可以通过使用合理的默认值和一组有限的常用参数值来进一步平衡这一点，这样热门路径仍然可以从结果缓存中受益。

一个实用的经验法则是：**保持数据集足够小以适合浏览器缓存，并使用字段筛选器实现交互性（最佳情况：无需往返数据仓库）。** 如果您不确定数据集是否能可靠地保持在浏览器缓存限制内，**请使用参数来提前缩减数据集**——这样数据仓库预先读取的数据就更少——然后再应用筛选器进行更深入的探索。这将把“先扫描所有数据再筛选”的仪表板转变为选择性的、可扩展的查询，从而在数据和用户增长时保持快速。

- https://medium.com/@andrea0pica/databricks-ai-bi-caching-explained-0c4de1aa946b

## 优化 #4：使用浏览器缓存

当交互是基于小数据集的字段筛选时，浏览器缓存最有帮助。一旦参数修改了SQL——或者数据集超过了浏览器阈值——交互就会转回数据仓库执行。

Databricks AI/BI仪表板可以将数据集结果直接缓存在用户的浏览器中，使得许多交互可以完全在客户端处理，无需往返SQL仓库。

当数据集大约低于10万行时，浏览器就成为一个本地执行引擎。交叉筛选、排序和简单聚合可以在内存中即时解析，实现近乎零延迟的交互，并完全消除后端并发压力。这就是为什么设计良好的概览页面即使在重度使用下也常常感觉“瞬间”响应的原因。

浏览器缓存在以下情况下会自动使用：

*   数据集足够小，可以安全地加载到浏览器中。
*   交互基于可以在客户端评估的字段筛选器或跨图表选择。
*   没有参数变更强制数据仓库重新执行SQL。

一旦数据集增长超过此阈值——或者当参数修改了底层SQL时——交互就会被推回数据仓库，浏览器缓存不再适用。

关键的设计要点是**有意识地控制数据集大小**。保持着陆页和概览数据集紧凑、预聚合，并专注于常见KPI，使其符合浏览器缓存的条件。这能提供即时的“首次绘制”，减少查询扇出，并为不可避免需要后端执行的更深层次调查页面保留数据仓库容量。

更多详情，请参阅：https://docs.databricks.com/aws/en/dashboards/caching#dataset-optimizations

## 优化 #5：最大化结果缓存的利用率

最便宜、最快的查询是您不执行的查询。

Databricks SQL结果缓存通过从缓存提供结果而非重新计算，将重复的仪表板交互转变为近乎即时的响应。

### 结果缓存的工作原理（缓存什么、在哪里、缓存多久）

Databricks SQL在执行查询前会检查缓存结果：

*   **本地结果缓存（所有仓库）**：每个集群的缓存。
*   **远程结果缓存（Serverless）**：工作区范围，并在仓库重启后**持久化**。

两种缓存都有大约**24小时的TTL**，并且**在底层表发生变化时失效**，因此您在保持数据新鲜度的同时也能从重用中受益。

### 设计仪表板以提高缓存命中率

缓存命中不是自动的——它们是设计的结果。当许多用户以**相同的方式**向数据仓库提出**相同的问题**时，您将获得最大的价值。

**1) 使图块具有确定性**
避免使用非确定性函数（例如，`NOW()`/`current_timestamp()`），因为它们会改变查询结果并阻止重用。优先使用显式的日期/时间参数，并保持查询文本稳定，以便相同的选择可以从缓存中提供。

**2) 重用数据集并保持查询“形态”一致**
当图块共享相同的数据集逻辑和一致的谓词 / GROUP BY 形态时，缓存和重用会显著改善。当多个可视化图表可以通过相同的后端查询（或相同的规范数据集）来回答时，您就减少了分发的语句数量**并**提高了缓存命中率。

**3) 注意身份和模拟**
当相同的查询在相同的访问上下文中执行时，结果缓存重用最为有效。如果您的设置对每个查看者使用**模拟**，您可能会降低缓存重用率，因为结果不能总是在不同身份之间安全共享。**最佳实践**：在安全和治理角度可接受的情况下，对于已发布的仪表板，优先使用共享的执行身份（例如，服务主体 / 共享访问上下文），以便重复查看可以从缓存重用中受益。如果必须使用按用户模拟，则通过最大化数据集重用并专注于确定性的、参数化的常见路径来弥补。

### 对于重复交互，优先使用Serverless

Serverless增加了远程结果缓存，该缓存在**整个工作区共享**，在重启后**持久存在**，并且也被**ODBC/JDBC**客户端和**SQL Statement API**使用。对于具有重复打开和常见筛选路径的仪表板，这通常能带来最大的“免费”性能提升。

### 主动预热缓存

对于已发布的仪表板，添加一个**计划**。计划任务在高峰时段前执行数据集逻辑并填充缓存，从而改善首次绘制并平滑整点时的突发流量。

### 验证命中（并避免误导性基准测试）

*   **查询历史记录**：`from_result_cache`和`cache_origin_statement_id`
*   `EXPLAIN EXTENDED`以了解缓存资格

注意事项：

*   本地缓存不会插入大于约**500 MiB**的结果（远程缓存没有大小限制）。
*   远程缓存需要支持**Cloud Fetch**的客户端（较旧的驱动程序可能无法命中）。

进行基准测试时，仅在受控测试期间禁用缓存：`SET use_cached_result = false`...并在实际使用中重新启用它，以便仪表板在生产环境中受益于缓存。

### 运维卫生：避免缓存污染

不要在同一BI仓库上混合不相关的工作负载。为每个领域/工作负载使用专用的**Serverless** BI仓库，有助于远程缓存填充那些对相应仪表板重要的重复查询。

更多详情，请参阅：https://www.databricks.com/blog/understanding-caching-databricks-sql-ui-result-and-disk-caches

## 展望：第二部分

本部分重点介绍了仪表板设计和交互模式如何在涉及数据仓库和数据之前就影响性能。通过减少扇出、优化首次绘制和最大化缓存重用，您通常可以在不改变底层数据的情况下获得巨大的性能提升。在**第二部分**中，我们将通过更深入地探讨平台来完成这幅图景：如何选择和调整合适的SQL仓库规模，数据建模和文件布局如何影响扫描效率，以及预计算、物化和数据类型如何在使用规模扩大时保持仪表板的快速和稳定。

---

> 本文由AI自动翻译，原文链接：[The Top 10 Best Practices for AI/BI Dashboards Performance Optimization (Part 1)](https://www.databricks.com/blog/top-10-best-practices-aibi-dashboards-performance-optimization-part-1)
> 
> 翻译时间：2026-02-05 04:18
