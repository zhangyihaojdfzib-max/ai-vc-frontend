---
title: 在Cloudflare平台构建垂直微前端：实现团队独立与统一体验
title_original: "Building vertical microfrontends on Cloudflareâ\x80\x99s platform"
date: '2026-01-30'
source: Cloudflare Blog
source_url: https://blog.cloudflare.com/vertical-microfrontends/
author: ''
summary: 本文介绍了Cloudflare推出的垂直微前端（VMFE）Worker模板，该架构允许不同团队通过URL路径（如/blog、/dash）完全独立地拥有各自的技术栈、框架和发布流程，同时向用户呈现统一的应用体验。文章探讨了如何通过路径映射独立Worker、利用CSS视图过渡实现视觉无缝衔接，以及解决多团队协作中的发布耦合问题，旨在帮助大型团队在隔离环境中高效工作，同时保持前端体验的一致性。
categories:
- 技术趋势
tags:
- 微前端
- Cloudflare
- 前端架构
- Web开发
- Worker
draft: false
translated_at: '2026-01-31T04:02:44.785345'
---

# 在 Cloudflare 平台上构建垂直微前端

2026-01-30

- Brayden Wilmoth

![](/images/posts/17a3f41ce780.png)

太平洋时间上午 6:55 更新

今天，我们推出一个用于垂直微前端（VMFE）的全新 Worker 模板。此模板允许您将多个独立的 Cloudflare Worker 映射到单个域名，使团队能够在完全隔离的环境中工作——独立发布营销页面、文档和仪表板——同时向用户呈现一个单一、无缝的应用程序。

大多数微前端架构都是"水平式"的，即单个页面的不同部分从不同服务获取。垂直微前端则采用不同方法，通过URL路径拆分应用。在这种模式下，负责`/blog`路径的团队不仅拥有一个组件，他们拥有该路由的完整垂直技术栈——框架选择、库选型、CI/CD流程等。拥有完整路径（或路径组）的技术栈，使团队能真正掌控自己的工作并自信地交付。

随着团队规模扩大，不同框架服务于不同使用场景的问题逐渐显现。例如营销网站可能更适合用Astro构建，而仪表盘可能更适合React。又或者，假设你有一个单体代码库，多个团队需要协同发布。当多个团队同时更新添加新功能时，可能因为某个团队引入回归问题而导致所有更新被回滚。我们该如何解决这个问题：既对用户隐藏技术实现细节，又让团队能完全自主地掌控各自领域，同时交付统一的用户体验？

垂直微前端可能是答案。让我们深入探讨它们如何共同解决开发者的痛点。

**什么是垂直微前端？**

垂直微前端是一种架构模式，单个独立团队拥有应用功能的完整垂直切片——从用户界面一直到CI/CD流水线。这些切片通过域名下的路径定义，您可以将独立的Worker与特定路径关联：

```
/      = 营销网站
/docs  = 文档
/blog  = 博客
/dash  = 仪表盘
```

我们还可以更进一步，关注更细粒度的子路径Worker关联，例如仪表盘。在仪表盘内部，您可能通过增加URL路径深度（如`/dash/product-a`）来划分不同功能或产品，在两个产品间导航可能意味着切换两个完全不同的代码库。

现在通过垂直微前端，我们还可以实现：

```
/dash/product-a  = WorkerA
/dash/product-b  = WorkerB
```

上述每个路径都是独立的前端项目，彼此间代码零共享。`product-a`和`product-b`路由映射到分别部署的前端应用，这些应用拥有由各自团队定义和掌控的独立框架、库和CI/CD流水线。终于实现了。

您现在可以端到端地掌控自己的代码。但现在我们需要找到一种方法，将这些独立项目缝合在一起，更重要的是让它们感觉像是统一的体验。

Cloudflare内部也深有体会，因为仪表盘有许多独立团队负责各自产品。团队必须面对一个事实：超出他们控制范围的变更会影响用户对其产品的体验。

我们在内部正为自家仪表盘采用类似策略。当用户从核心仪表盘导航到ZeroTrust产品时，实际上这是两个完全独立的项目，用户只是通过路径`/:accountId/one`被路由到该项目。

**视觉统一体验**

将这些独立项目缝合在一起，让它们感觉像是统一体验，并不像想象中那么困难：只需几行CSS魔法。我们**绝对不希望**发生的是向用户泄露实现细节和内部决策。如果我们未能让用户体验感觉像是统一的前端，那对用户就太不公平了。

为了实现这种无缝衔接，让我们先了解视图过渡和文档预加载如何发挥作用。

**视图过渡**

当我们希望在两个不同页面间无缝导航，让终端用户感觉流畅时，**视图过渡**非常有用。定义页面上特定的**DOM元素**在下一页可见前保持原位，并定义如何处理任何变化，这为多页面应用提供了强大的缝合工具。

然而，在某些情况下，让不同垂直微前端保持差异是完全可接受的。例如，我们的营销网站、文档和仪表盘可能各有独特设计。用户不会期望这三部分在导航时感觉统一。但是……如果您决定对单个体验（如仪表盘）引入垂直切片（例如`/dash/product-a`和`/dash/product-b`），那么用户**绝不应该**知道底层是两个不同的代码库/Worker/项目。

好了，说得够多了——让我们开始工作。我提到过让两个独立项目对用户感觉像是一个项目并不费力，如果您还没听说过**CSS视图过渡**，接下来会让您大开眼界。

如果我告诉您，您可以在不同视图间实现动画过渡——无论是单页面应用（SPA）还是多页面应用（MPA）——让它们感觉像是一个整体呢？在添加任何视图过渡之前，如果我们在两个不同Worker拥有的页面间导航，浏览器会显示数百毫秒的空白白屏作为加载过渡状态，直到下一页开始完整渲染。页面会感觉不连贯，肯定不像单页面应用。

*显示为各站点间的多次导航元素。*

如果我们希望某些元素保持原位，而不是看到空白页面，可以通过定义CSS视图过渡来实现。使用以下代码，我们告诉当前文档页面：当视图过渡事件即将发生时，保持`nav` DOM元素在屏幕上，如果现有页面与目标页面外观存在任何差异，我们将用`ease-in-out`过渡动画处理。

突然间，两个不同的Worker感觉像是一个。

```css
@supports (view-transition-name: none) {
  ::view-transition-old(root),
  ::view-transition-new(root) {
    animation-duration: 0.3s;
    animation-timing-function: ease-in-out;
  }
  nav { view-transition-name: navigation; }
}
```

*显示为三个独立站点间的单一导航元素。*

**预加载**

页面间过渡让体验**看起来**无缝——我们还希望它**感觉**像客户端SPA一样即时。虽然目前Firefox和Safari不支持**推测规则**，但Chrome/Edge/Opera支持这个较新的功能。推测规则API旨在提升未来导航的性能，特别是文档URL的导航，让多页面应用感觉更像单页面应用。

用代码分解，我们需要以特定格式定义脚本规则，告诉支持该功能的浏览器如何预取连接到我们Web应用的其他垂直切片——这些切片可能通过某些共享导航链接。

```html
<script type="speculationrules">
  {
    "prefetch": [
      {
        "urls": ["https://product-a.com", "https://product-b.com"],
        "requires": ["anonymous-client-ip-when-cross-origin"],
        "referrer_policy": "no-referrer"
      }
    ]
  }
</script>
```

这样，我们的应用会预取其他微前端并将其保存在内存缓存中，因此导航到那些页面时感觉几乎是即时的。

对于明显可区分的垂直切片（营销、文档、仪表盘），您可能不需要这个功能，因为用户会预期它们之间有轻微加载。但是，当垂直切片定义在特定可见体验内时（例如仪表盘页面之间），强烈建议使用。

通过**视图过渡**和**推测规则**，我们能够将完全不同的代码库捆绑在一起，让它们感觉像是来自单页面应用。在我看来这很神奇。

**零配置请求路由**

现在我们需要一种托管多个应用的机制，以及一种在请求流入时将它们缝合在一起的方法。

将单个 Cloudflare Worker 定义为“路由器”，允许一个单一的逻辑点（在边缘）处理网络请求，然后将其转发给负责该 URL 路径的垂直微前端。此外，这样做的好处是我们可以将单个域名映射到该路由器 Worker，其余部分“就能正常工作”。

**服务绑定**
如果你尚未探索过 Cloudflare Worker 的服务绑定，那么值得花点时间了解一下。服务绑定允许一个 Worker 调用另一个 Worker，而无需通过公开可访问的 URL。服务绑定允许 Worker A 调用 Worker B 上的方法，或者将请求从 Worker A 转发到 Worker B。进一步分解，路由器 Worker 可以调用每个已定义的垂直微前端 Worker（例如营销、文档、仪表板），前提是它们都是 Cloudflare Worker。

为什么这很重要？这正是将这些垂直切片“缝合”在一起的机制。我们将在下一节深入探讨请求路由如何处理流量分割。但要定义这些微前端中的每一个，我们需要更新路由器 Worker 的 wrangler 定义，以便它知道允许调用哪些前端。
```
{
  "$schema": "./node_modules/wrangler/config-schema.json",
  "name": "router",
  "main": "./src/router.js",
  "services": [
    {
      "binding": "HOME",
      "service": "worker_marketing"
    },
    {
      "binding": "DOCS",
      "service": "worker_docs"
    },
    {
      "binding": "DASH",
      "service": "worker_dash"
    },
  ]
}
```
我们上面的示例定义是在路由器 Worker 中定义的，它告诉我们允许向三个独立的附加 Worker（营销、文档和仪表板）发出请求。授予权限就这么简单，但让我们深入了解一些更复杂的逻辑，包括请求路由和 HTML 重写网络响应。

**请求路由**
了解了我们在需要时可以调用的各种其他 Worker 后，现在我们需要一些逻辑来确定何时将网络请求定向到哪里。由于路由器 Worker 被分配给了我们的自定义域名，所有传入请求首先在网络边缘到达它。然后它决定应由哪个 Worker 处理该请求并管理响应结果。

第一步是将 URL 路径映射到关联的 Worker。当收到某个请求 URL 时，我们需要知道它需要被转发到哪里。我们通过定义规则来实现这一点。虽然我们支持通配符路由、动态路径和参数约束，但我们将专注于基础——字面路径前缀——因为这能更清晰地说明问题。

在这个例子中，我们有三个微前端：
```
/      = 营销
/docs  = 文档
/dash  = 仪表板
```
上述每个路径都需要映射到一个实际的 Worker（请参阅上一节中我们关于服务的 wrangler 定义）。对于我们的路由器 Worker，我们使用以下数据定义一个额外的变量，这样我们就可以知道哪些路径应该映射到哪些服务绑定。现在，当请求进来时，我们知道将用户路由到哪里！定义一个名为 ROUTES 的 wrangler 变量，内容如下：
```
{
  "routes":[
    {"binding": "HOME", "path": "/"},
    {"binding": "DOCS", "path": "/docs"},
    {"binding": "DASH", "path": "/dash"}
  ]
}
```
让我们设想一个用户访问我们网站的路径 `/docs/installation`。在底层，发生的情况是请求首先到达我们的路由器 Worker，它负责理解哪些 URL 路径映射到哪些独立的 Worker。它知道 `/docs` 路径前缀映射到我们的 `DOCS` 服务绑定，而参考我们的 wrangler 文件，这指向我们的 `worker_docs` 项目。我们的路由器 Worker 知道 `/docs` 被定义为一个垂直微前端路由，于是从路径中移除 `/docs` 前缀，将请求转发给我们的 `worker_docs` Worker 来处理，最后返回我们得到的任何响应。

但是，为什么要丢弃 `/docs` 路径呢？这是一个实现细节上的选择，目的是当通过路由器 Worker 访问该 Worker 时，它可以清理 URL 来处理请求，**就像**它是从我们路由器 Worker 外部调用的一样。像任何 Cloudflare Worker 一样，我们的 `worker_docs` 服务可能拥有自己独立的可访问 URL。我们决定希望该服务 URL 能继续独立工作。当它附加到我们的新路由器 Worker 时，它会自动处理移除前缀，这样该服务就可以从其自身定义的 URL 或通过我们的路由器 Worker 访问……无论哪个地方，都没关系。

**HTMLRewriter**
通过 URL 路径（例如 `/docs` 或 `/dash`）拆分我们的各种前端服务使我们能够轻松地转发请求，但当我们的响应包含不知道它正在通过路径组件被反向代理的 HTML 时……嗯，这会导致问题。

假设我们的文档网站在响应中有一个图片标签 `<img src="./logo.png" />`。如果我们的用户是在 `https://website.com/docs/` 访问此页面，那么加载 `logo.png` 文件可能会失败，因为我们的 `/docs` 路径在某种程度上只是由我们的路由器 Worker 人为定义的。

只有当通过我们的路由器 Worker 访问我们的服务时，我们才需要对绝对路径进行一些 HTML 重写，以便我们返回的浏览器响应引用有效的资源。实际上发生的情况是，当请求通过我们的路由器 Worker 时，我们将请求传递给正确的服务绑定，并接收来自该绑定的响应。在将其传回客户端之前，我们有机会重写 DOM——所以当我们看到绝对路径时，我们就为其加上代理路径的前缀。以前我们的 HTML 返回的图片标签是 `<img src="./logo.png" />`，现在我们在返回给客户端浏览器之前将其修改为 `<img src="./docs/logo.png" />`。

让我们暂时回到 CSS 视图过渡和文档预加载的魔力。我们当然可以手动将这些代码放入我们的项目并使其工作，但这个路由器 Worker 也将通过使用 `HTMLRewriter` **自动**为我们处理该逻辑。

在你的路由器 Worker 的 `ROUTES` 变量中，如果你在根级别将 `smoothTransitions` 设置为 `true`，那么 CSS 过渡视图代码将被自动添加。此外，如果你将路由内的 `preload` 键设置为 `true`，那么该路由的脚本代码推测规则也将被自动添加。

下面是一个两者同时生效的示例：
```
{
  "smoothTransitions":true, 
  "routes":[
    {"binding": "APP1", "path": "/app1", "preload": true},
    {"binding": "APP2", "path": "/app2", "preload": true}
  ]
}
```

**开始使用**
你现在就可以开始使用垂直微前端模板进行构建。

访问 Cloudflare 仪表板[深度链接](此处)或转到“Workers & Pages”并点击“Create application”按钮开始。从那里，点击“Select a template”，然后选择“Create microfrontend”，你就可以开始配置你的设置了。

查看[文档](documentation)以了解如何映射你现有的 Worker 并启用视图过渡。我们迫不及待想看到你在边缘构建的复杂、多团队应用程序！

大多数微前端架构是“水平”的，意味着单个页面的不同**部分**是从不同服务获取的。垂直微前端采用了一种不同的方法，即按 URL 路径拆分应用程序。在这种模型中，拥有 `/blog` 路径的团队**不仅仅**拥有一个组件；他们拥有该路由的整个垂直技术栈——框架、库选择、CI/CD 等等。拥有一个路径或一组路径的整个技术栈，使团队能够真正拥有其工作的所有权，并充满信心地进行交付。

随着团队规模扩大，他们会面临各种问题，不同的框架适用于不同的使用场景。例如，营销网站可能更适合使用Astro，而仪表盘则可能更适合React。或者，假设你有一个单体代码库，多个团队在其中协同发布。当多个团队同时更新以添加新功能时，可能会因为某个团队引入了回归问题而导致更新被令人沮丧地回滚。我们如何解决这个问题，即向用户隐藏技术实现细节，同时让团队能够完全自主地控制其领域，并交付一个连贯的用户体验？

垂直微前端可能是答案。让我们深入探讨它们如何共同解决开发者的痛点。

## 什么是垂直微前端？

垂直微前端是一种架构模式，其中一个独立的团队拥有应用程序功能的完整切片，从用户界面一直到CI/CD流水线。这些切片由域上的路径定义，你可以将单个Worker与特定路径关联起来：

```Rust
/      = 营销
/docs  = 文档
/blog  = 博客
/dash  = 仪表盘
```

我们可以更进一步，专注于更细粒度的子路径Worker关联，例如仪表盘。在仪表盘内部，你可能通过增加URL路径深度（例如`/dash/product-a`）来划分各种功能或产品，并且在两个产品之间导航可能意味着两个完全不同的代码库。

现在，有了垂直微前端，我们还可以有以下配置：

```Rust
/dash/product-a  = WorkerA
/dash/product-b  = WorkerB
```

上述每个路径都是它们自己的前端项目，彼此之间没有共享代码。`product-a`和`product-b`路由映射到分别部署的前端应用程序，这些应用程序拥有自己的框架、库、CI/CD流水线，并由各自的团队定义和拥有。终于实现了。

你现在可以端到端地拥有自己的代码了。但现在我们需要找到一种方法，将这些独立的项目缝合在一起，更重要的是，让它们感觉像是一个统一的体验。

我们在Cloudflare内部也亲身体验到了这个痛点，因为仪表盘有许多独立的团队负责各自的产品。团队必须面对这样一个事实：超出他们控制范围的更改会影响用户对其产品的体验。

在内部，我们现在为自己的仪表盘采用了类似的策略。当用户从核心仪表盘导航到我们的ZeroTrust产品时，实际上它们是两个完全独立的项目，用户只是通过其路径`/:accountId/one`被路由到那个项目。

## 视觉统一的体验

将这些独立的项目缝合在一起，让它们感觉像是一个统一的体验，并不像你想象的那么困难：只需要几行CSS魔法。我们**绝对不希望**发生的是，将我们的实现细节和内部决策泄露给用户。如果我们未能让这种用户体验感觉像一个连贯的前端，那么我们就对我们的用户造成了严重的不公。

为了实现这种障眼法，让我们花点时间了解一下视图过渡和文档预加载是如何发挥作用的。

### 视图过渡

当我们想要在用户无感知的情况下，在两个不同的页面之间无缝导航，使其感觉流畅时，**视图过渡**非常有用。定义我们页面上的特定**DOM元素**，使其在下一个页面可见之前保持不动，并定义如何处理任何变化，这为多页面应用程序提供了一个非常强大的缝合工具。

然而，在某些情况下，让不同的垂直微前端感觉不同是完全可接受的。例如，我们的营销网站、文档和仪表盘可能各自有独特的定义。用户不会期望在这三个部分之间导航时，它们都感觉是连贯的。但是……如果你决定在单个体验（如仪表盘）中引入垂直切片（例如`/dash/product-a`和`/dash/product-b`），那么用户**永远不应该**知道它们底层是两个不同的仓库/Worker/项目。

好了，说得够多了——让我们开始工作吧。我提到过，让两个独立的项目对用户来说感觉像是一个项目是低成本的，如果你还没听说过**CSS视图过渡**，那么我即将让你大开眼界。

如果我告诉你，你可以在不同视图之间（无论是单页面应用（SPA）还是多页面应用（MPA））制作动画过渡，让它们感觉像是一个整体，你会怎么想？在添加任何视图过渡之前，如果我们在由两个不同Worker拥有的页面之间导航，浏览器中会出现空白屏幕的间隙加载状态，持续几百毫秒，直到下一个完整页面开始渲染。页面之间会感觉不连贯，当然也不会感觉像是一个单页面应用。

表现为每个站点之间有多个导航元素。

如果我们希望某些元素保持不动，而不是看到一个空白页面，我们可以通过定义CSS视图过渡来实现。使用下面的代码，我们告诉当前文档页面，当视图过渡事件即将发生时，将`nav` DOM元素保留在屏幕上，并且如果现有页面和目标页面之间存在任何外观差异，那么我们将使用`ease-in-out`过渡来动画化这些差异。

突然间，两个不同的Worker感觉像是一个。

```CSS
@supports (view-transition-name: none) {
  ::view-transition-old(root),
  ::view-transition-new(root) {
    animation-duration: 0.3s;
    animation-timing-function: ease-in-out;
  }
  nav { view-transition-name: navigation; }
}
```

表现为三个不同站点之间有一个单一的导航元素。

### 预加载

页面之间的过渡使其**看起来**无缝——我们也希望它**感觉**像客户端SPA一样即时。虽然目前Firefox和Safari不支持**推测规则**，但Chrome/Edge/Opera支持这个较新的功能。推测规则API旨在提高未来导航的性能，特别是对于文档URL，使多页面应用感觉更像单页面应用。

将其分解为代码，我们需要定义的是一个特定格式的脚本规则，告诉支持该功能的浏览器如何预取连接到我们Web应用程序的其他垂直切片——这些切片很可能通过某些共享导航链接起来。

```JavaScript
<script type="speculationrules">
  {
    "prefetch": [
      {
        "urls": ["https://product-a.com", "https://product-b.com"],
        "requires": ["anonymous-client-ip-when-cross-origin"],
        "referrer_policy": "no-referrer"
      }
    ]
  }
</script>
```

这样，我们的应用程序就会预取其他微前端，并将它们保存在内存缓存中，因此如果我们导航到这些页面，感觉几乎是即时的。

对于明显可区分的垂直切片（营销、文档、仪表盘），你可能不需要这个，因为用户会期望它们之间有轻微的加载。但是，强烈建议在特定可见体验（例如仪表盘页面内）内定义垂直切片时使用。

通过**视图过渡**和**推测规则**，我们能够将完全不同的代码仓库捆绑在一起，让它们感觉像是从一个单页面应用提供的。如果你问我，这太神奇了。

## 零配置请求路由

现在我们需要一种机制来托管多个应用程序，以及一种在请求流入时将它们缝合在一起的方法。将单个Cloudflare Worker定义为“路由器”，可以在边缘提供一个单一的逻辑点来处理网络请求，然后将它们转发给负责该URL路径的垂直微前端。此外，这样做的好处是，我们可以将单个域映射到该路由器Worker，其余的“就能正常工作”。

### 服务绑定

如果你还没有探索过Cloudflare Worker的**服务绑定**，那么值得花点时间了解一下。

服务绑定允许一个Worker调用另一个Worker，而无需通过公开可访问的URL。服务绑定使得Worker A可以调用Worker B上的方法，或者将来自Worker A的请求转发给Worker B。进一步分解，假设每个垂直微前端Worker（例如营销、文档、仪表板）都是Cloudflare Workers，那么路由器Worker就可以调用每个已定义的垂直微前端Worker。

这为什么重要？这正是将这些垂直切片“缝合”在一起的机制。我们将在下一节深入探讨请求路由如何处理流量分割。但要定义这些微前端中的每一个，我们需要更新路由器Worker的wrangler定义，以便它知道允许调用哪些前端。

```JSON
{
  "$schema": "./node_modules/wrangler/config-schema.json",
  "name": "router",
  "main": "./src/router.js",
  "services": [
    {
      "binding": "HOME",
      "service": "worker_marketing"
    },
    {
      "binding": "DOCS",
      "service": "worker_docs"
    },
    {
      "binding": "DASH",
      "service": "worker_dash"
    },
  ]
}
```

我们上面的示例定义是在路由器Worker中定义的，它告诉我们允许向三个独立的附加Worker（营销、文档和仪表板）发出请求。授予权限就这么简单，但让我们深入了解一些更复杂的逻辑，包括请求路由和HTML重写网络响应。

### 请求路由

既然知道了在需要时可以调用的其他各种Worker，我们现在需要一些逻辑来确定何时将网络请求定向到哪里。由于路由器Worker被分配给了我们的自定义域名，所有传入的请求首先在网络边缘到达它。然后它决定应由哪个Worker处理该请求，并管理最终的响应。

第一步是将URL路径映射到关联的Worker。当收到某个请求URL时，我们需要知道它需要被转发到哪里。我们通过定义规则来实现这一点。虽然我们支持通配符路由、动态路径和参数约束，但我们将专注于基础——字面路径前缀——因为这能更清晰地说明问题。

在这个例子中，我们有三个微前端：

```Rust
/      = 营销
/docs  = 文档
/dash  = 仪表板
```

上述每个路径都需要映射到一个实际的Worker（请参阅上一节中我们关于服务的wrangler定义）。对于我们的路由器Worker，我们定义了一个包含以下数据的附加变量，这样我们就可以知道哪些路径应该映射到哪些服务绑定。现在，当请求进来时，我们就知道将用户路由到哪里了！定义一个名为ROUTES的wrangler变量，内容如下：

```JSON
{
  "routes":[
    {"binding": "HOME", "path": "/"},
    {"binding": "DOCS", "path": "/docs"},
    {"binding": "DASH", "path": "/dash"}
  ]
}
```

让我们设想一个用户访问我们的网站路径 `/docs/installation`。在底层，发生的情况是请求首先到达我们的路由器Worker，它负责理解哪些URL路径映射到哪些独立的Worker。它知道 `/docs` 路径前缀映射到我们的 `DOCS` 服务绑定，而参考我们的wrangler文件，这指向我们的 `worker_docs` 项目。我们的路由器Worker知道 `/docs` 被定义为一个垂直微前端路由，于是从路径中移除 `/docs` 前缀，并将请求转发给我们的 `worker_docs` Worker 来处理请求，最后返回我们得到的任何响应。

但是，它为什么要丢弃 `/docs` 路径呢？这是一个实现细节上的选择，目的是当Worker通过路由器Worker访问时，它可以清理URL来处理请求，**就像**它是从我们的路由器Worker外部调用的一样。与任何Cloudflare Worker一样，我们的 `worker_docs` 服务可能有一个可以访问的独立URL。我们决定希望该服务URL能够继续独立工作。当它附加到我们的新路由器Worker时，它会自动处理移除前缀，因此该服务可以从其定义的URL或通过我们的路由器Worker访问……无论哪个地方，都没关系。

### HTMLRewriter

使用URL路径（例如 `/docs` 或 `/dash`）来分割我们的各种前端服务，使我们能够轻松地转发请求，但是当我们的响应包含不知道它正在通过路径组件被反向代理的HTML时……嗯，这就会导致问题。

假设我们的文档网站在响应中有一个图片标签 `<img src="./logo.png" />`。如果我们的用户是在 `https://website.com/docs/` 访问此页面，那么加载 `logo.png` 文件很可能会失败，因为我们的 `/docs` 路径在某种程度上只是由我们的路由器Worker人为定义的。

只有当我们的服务通过路由器Worker访问时，我们才需要对绝对路径进行一些HTML重写，以便我们返回的浏览器响应引用有效的资源。实际上发生的情况是，当请求通过我们的路由器Worker时，我们将请求传递给正确的服务绑定，并接收来自该绑定的响应。在我们将其返回给客户端之前，我们有机会重写DOM——所以当我们看到绝对路径时，我们就继续在其前面加上代理路径。之前我们的HTML返回的图片标签是 `<img src="./logo.png" />`，现在我们在返回给客户端浏览器之前将其修改为 `<img src="./docs/logo.png" />`。

让我们暂时回到CSS视图过渡和文档预加载的魔力。我们当然可以手动将这些代码放入我们的项目中并使其工作，但这个路由器Worker也将通过使用 `HTMLRewriter` **自动**为我们处理该逻辑。

在你的路由器Worker的 `ROUTES` 变量中，如果你在根级别将 `smoothTransitions` 设置为 `true`，那么CSS过渡视图代码将被自动添加。此外，如果你将路由内的 `preload` 键设置为 `true`，那么该路由的脚本代码推测规则也将被自动添加。

下面是一个两者同时生效的示例：

```JSON
{
  "smoothTransitions":true, 
  "routes":[
    {"binding": "APP1", "path": "/app1", "preload": true},
    {"binding": "APP2", "path": "/app2", "preload": true}
  ]
}
```

## 开始使用

您今天就可以开始使用垂直微前端模板进行构建。

访问Cloudflare仪表板[此处](deeplink here)的深度链接，或转到“Workers & Pages”并点击“Create application”按钮开始。从那里，点击“Select a template”，然后点击“Create microfrontend”，您就可以开始配置您的设置了。

查看[文档](documentation)以了解如何映射您现有的Worker并启用视图过渡。我们迫不及待想看到您在边缘构建的复杂、多团队应用程序！

---

> 本文由AI自动翻译，原文链接：[Building vertical microfrontends on Cloudflareâs platform](https://blog.cloudflare.com/vertical-microfrontends/)
> 
> 翻译时间：2026-01-31 04:02
