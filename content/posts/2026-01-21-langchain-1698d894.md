---
title: 使用Deep Agents构建多智能体应用：解决上下文膨胀与专业化分工
title_original: Building Multi-Agent Applications with Deep Agents
date: '2026-01-21'
source: LangChain Blog
source_url: https://www.blog.langchain.com/building-multi-agent-applications-with-deep-agents/
author: ''
summary: 本文介绍了如何使用Deep Agents框架构建多智能体系统，重点探讨了子智能体和技能两个核心原语。子智能体通过隔离工作上下文，有效解决了智能体工程中的上下文膨胀问题，避免主智能体因中间结果过多而进入性能下降的“愚钝区”。文章详细说明了子智能体的适用场景、配置方法及最佳实践，包括专业化分工、多模型选择、并行化执行等优势，为构建高效、可扩展的AI系统提供了实用指导。
categories:
- AI产品
tags:
- 多智能体系统
- Deep Agents
- 上下文管理
- AI工程
- 智能体架构
draft: false
translated_at: '2026-01-22T04:51:31.337111'
---

![构建多智能体应用](/images/posts/7c49b0384e75.png)


# 使用 Deep Agents 构建多智能体应用

将复杂任务分解给专门的智能体是构建强大 AI 系统最有效的方法之一。在本文中，我们将向您展示如何使用 Deep Agents 构建多智能体系统。

作者：Sydney Runkle 和 Vivek Trendy

将复杂任务分解给专门的智能体是构建强大 AI 系统最有效的方法之一。

Deep Agents 通过两个一等公民的原语使这一切变得简单：

- **子智能体**：委托给独立的智能体
- **技能**：渐进式地披露能力

在本文中，我们将向您展示如何使用 Deep Agents 构建多智能体系统。

## 使用子智能体：专门的、独立的工作者

子智能体解决了智能体工程中的一个基本问题：**上下文膨胀**。这是指智能体在处理任务时，其上下文窗口接近被填满的情况。

为什么这很重要？Chroma 在**上下文衰减**方面做了出色的研究，表明随着上下文窗口被填满，模型完成任务会变得困难。我们在 HumanLayer 的朋友将这种高上下文状态称为“愚钝区”。子智能体将上下文与主智能体隔离，有助于避免快速进入愚钝区。

当您的智能体进行数十次网络搜索或文件读取时，上下文窗口会充满中间结果。子智能体通过在自己的上下文窗口中运行来隔离工作。因此，即使子智能体在得出最终答案之前做了大量探索性工作，主智能体仍然只得到最终结果，而不是产生该结果的 20 个工具调用。

以下是基本的子智能体架构概览：

![](/images/posts/d8ccdac4b37a.png)


### 何时使用子智能体

- **上下文保持**：需要多个步骤的任务可能会弄乱主智能体的上下文（例如：代码库探索）。
- **专业化**：使用特定领域的指令或工具。由不同团队开发的子智能体可以专注于不同的垂直领域。
- **多模型**：子智能体可以使用与主智能体不同的模型。例如，选择更小的模型以降低延迟。
- **并行化**：子智能体可以同时运行，并将输出返回给主智能体。这减少了延迟。

将子智能体定义为字典并传递给 `create_deep_agent()`：

```
from deepagents import create_deep_agent

research_subagent = {
    "name": "research-agent",
    "description": "用于深入研究问题",
    "system_prompt": "你是一名出色的研究员",
    "tools": [internet_search],
    "model": "openai:gpt-4o",  # 可选：覆盖主智能体模型
}

agent = create_deep_agent(
    model="claude-sonnet-4-5-20250929",
    subagents=[research_subagent]
)

```

有关配置详情，请参阅 `subagents` 文档。

### 通用子智能体

Deep Agents 包含一个内置的**通用**子智能体，它镜像了您主智能体的能力。它具有相同的系统提示词、工具和模型。这非常适合**上下文隔离**，而无需专门的行为。

示例：与其让主智能体进行 10 次网络搜索并填满其上下文，不如将其委托给通用子智能体，使用 `task(name="general-purpose", task="研究量子计算趋势")`。子智能体在内部执行所有搜索，并仅返回摘要。

### 子智能体的最佳实践

**编写清晰的描述。** 您的主智能体使用描述来决定调用哪个子智能体：

✅ 良好："分析财务数据并生成带有置信度评分的投资见解"
❌ 不佳："处理财务相关事务"

**保持系统提示词详细。** 包含工具使用指导和输出格式要求：

```
    "description": "使用网络搜索进行深入研究并综合发现",
    "system_prompt": """你是一名细致的研究员。你的工作是：

    1. 将研究问题分解为可搜索的查询
    2. 使用 internet_search 查找相关信息
    3. 将发现综合成全面但简洁的摘要
    4. 提出主张时引用来源

    输出格式：
    - 摘要（2-3 段）
    - 关键发现（要点列表）
    - 来源（附 URL）

    将回复控制在 500 字以内以保持上下文简洁。""",
}

```

**最小化工具集。** 只给予智能体它们需要的工具：

```
# ✅ 良好：专注的工具集
email_agent = {
    "name": "email-sender",
    # 仅与邮件相关
    "tools": [send_email, validate_email],
}

# ❌ 不佳：工具过多
email_agent = {
    # 不专注
    "tools": [send_email, web_search, database_query, file_upload],
}

```

## 使用技能：能力的渐进式披露

技能提供了一种不同的模式：**渐进式披露**。您无需预先给智能体提供数十个工具，而是在 `SKILL.md` 文件中定义专门的能力。您的智能体看到技能名称和描述，然后仅在需要时读取完整的指令。

![技能描述会预加载到上下文窗口中。技能主体仅在智能体根据描述和先前上下文判断需要该技能时才加载。](/images/posts/918eccd609de.png)


图注：技能描述会预加载到上下文窗口中。技能主体仅在智能体根据描述和先前上下文判断需要该技能时才加载。

技能使用 agentskills.io 规范。以下是其结构：

```
.deepagents/skills/
├── deploy/SKILL.md
└── review-pr/SKILL.md

```

每个 `SKILL.md` 文件都包含带有元数据的 YAML 前言和主体部分：

```
name: deploy
description: 部署到生产环境
version: 1.0.0  # 可选
tags: [deployment, production]  # 可选

# 部署到生产环境

当用户要求部署时，请遵循以下步骤：

1. 运行测试：`npm test`
2. 构建应用：`npm run build`
3. 部署到生产环境：`npm run deploy:prod`
4. 验证部署：检查健康端点

部署到生产环境前务必与用户确认。

```

### 为您的智能体添加技能

使用 `create_deep_agent` 的 `skills` 参数从文件系统加载技能：

```
from deepagents.backends import FilesystemBackend

    backend=FilesystemBackend(root_dir="/"),
    skills=[".deepagents/skills"],
)

```

现在智能体可以看到您的技能。当它需要详细指令时，它会读取完整的 `SKILL.md` 文件。

您也可以使用其他后端（例如 `StateBackend` 或 `StoreBackend`），然后通过 `files` 规范调用智能体：

```
from deepagents.middleware.filesystem import FileData

# 默认后端是 StateBackend
    model="anthropic:claude-sonnet-4-20250514",
    skills=["/skills/"],
)

skill_content = """
name: deploy
...
"""

# 使用技能和虚拟文件调用智能体
result = agent.invoke({
    "messages": [HumanMessage(content="研究最新的 Python 版本发布")],
    "files": {
        "/skills/web-research/SKILL.md": FileData(
            content=skill_content.split("\n"),
            created_at="2024-01-01T00:00:00Z",
            modified_at="2024-01-01T00:00:00Z",
        ),
    },
})

```

## 选择正确的模式

以下是一组快速问题来指导您：

要了解更多关于 Deep Agents 中的多智能体模式，请查看我们的：

- **子智能体文档** - 详细的 API 参考和示例
- **技能文档** - 详细的 API 参考和示例
- **多智能体模式指南** - 关于选择模式的一般指导

关键见解：多智能体模式不必复杂。借助正确的抽象（用于管道的中间件，用于调用的工具调用），它们可以成为简单的构建块，您可以将其组合成强大、复杂的系统。

从上下文管理的子智能体（Agent）起步，逐步添加技能以实现渐进式信息呈现，并在此基础上持续构建。

来自 LangChain 团队和社区的更新

正在处理您的申请...

成功！请检查您的收件箱并点击链接确认订阅。

抱歉，出错了。请重试。

![Agent Builder 模板介绍](/images/posts/3a612c8385be.png)

## 通过 Agent Builder 模板即时部署智能体（Agent）

![LangSmith Agent Builder 现已全面可用](/images/posts/0c37946eb9e8.png)

## 现已全面可用：LangSmith Agent Builder

## 2025年5月1日 LangSmith 事件

![LangGraph 记忆的语义搜索](/images/posts/a14874dfc6e5.png)

## LangGraph 记忆的语义搜索

![反思型智能体（Agent）](/images/posts/c181a708942e.jpg)

![计划+执行智能体（Agent）缩略图](/images/posts/b83f670ff6d7.png)

## 计划与执行智能体（Agent）


> 本文由AI自动翻译，原文链接：[Building Multi-Agent Applications with Deep Agents](https://www.blog.langchain.com/building-multi-agent-applications-with-deep-agents/)
> 
> 翻译时间：2026-01-22 04:51
