---
title: AI Agent的“事实来源”：从代码到痕迹
title_original: In software, the code documents the app. In AI, the traces do.
date: '2026-01-10'
source: LangChain Blog
source_url: https://blog.langchain.com/in-software-the-code-documents-the-app-in-ai-the-traces-do/
author: ''
summary: 本文探讨了AI Agent与传统软件在构建和调试方式上的根本差异。在传统软件中，代码是应用逻辑的“事实来源”，决策过程清晰可见。而在AI Agent中，代码仅作为编排模型的脚手架，真正的决策逻辑发生在运行时的大语言模型内部。因此，理解Agent行为的关键不再是代码，而是其执行过程中产生的“痕迹”——记录推理步骤、工具调用和结果的日志。这一转变要求开发者将调试、测试、优化和监控的重心从代码分析转向痕迹分析，通过比较和回放痕迹来洞察Agent的实际决策过程，从而有效提升其性能和可靠性。
categories:
- AI产品
tags:
- AI Agent
- 可观测性
- 调试
- 痕迹分析
- 大语言模型
draft: false
translated_at: '2026-01-11T04:44:39.489012'
---

![In software, the code documents the app. In AI, the traces do.](/images/posts/a8083a77f8e4.png)

![In software, the code documents the app. In AI, the traces do.](/images/posts/a8083a77f8e4.png)

# 在软件中，代码记录应用。在AI中，痕迹记录应用。

*   在传统软件中，你通过阅读代码来理解应用的功能——决策逻辑存在于你的代码库中。
*   在AI Agent（智能体）中，代码只是脚手架——实际的决策发生在运行时的模型中。
*   因此，关于你的应用功能的“事实来源”从代码转移到了痕迹——痕迹记录了你的Agent实际做了什么以及为什么这么做。
*   这改变了我们调试、测试、优化、监控、协作和理解产品使用的方式。
*   如果你在没有良好可观测性的情况下构建Agent，你就错过了了解系统实际功能的“事实来源”。

在传统软件中，当出现问题时，你阅读代码。当你想了解一个功能如何工作时，你阅读代码。当你想提升性能时，你分析代码。代码就是“事实来源”。

在AI Agent中，这套方法不再适用。

## 为什么代码无法记录Agent行为

在传统软件中，如果你想了解用户提交表单时会发生什么，你会打开 `handleSubmit()` 函数并阅读它。决策逻辑就在那里：验证输入、检查认证、调用API、处理错误。它是确定性的——相同的输入、相同的代码路径、相同的输出。

在AI Agent中，代码只是脚手架。

以下是Agent代码的一个简化版本：

```
agent = Agent(
    model="gpt-4",
    tools=[search_tool, analysis_tool, visualization_tool],
    system_prompt="You are a helpful data analyst..."
)
result = agent.run(user_query)

```

你定义了各个部分：使用哪个模型、哪些工具、什么指令。但决策逻辑并不在你的代码里。你的代码只是编排LLM（大语言模型）的调用。

实际的决策——何时调用哪个工具、如何推理问题、何时停止、优先处理什么——所有这些都发生在运行时的模型中。

你仍然可以调试你的编排代码——工具调用是否工作、解析是否正常。但你无法调试“智能”。Agent是否做出了好的决策、是否有效地推理——这些逻辑存在于模型中，而不是你的代码库里。

## 痕迹作为新的文档

那么，实际的行为存在于哪里呢？在痕迹里。

痕迹是Agent执行的一系列步骤。它记录了你的应用的逻辑——每一步的推理、调用了哪些工具及其原因、结果和耗时。

调试、测试、性能分析、监控——所有这些操作都从基于代码转向了基于痕迹。

在传统软件中，如果两次运行产生不同的输出，你会假设是输入不同或代码不同。在AI Agent中，相同的输入和相同的代码可能产生不同的输出。不同的工具调用、不同的推理链、不同的结果。

理解发生了什么事的唯一方法是查看痕迹。为什么任务A成功而任务B失败？比较痕迹。你的提示词（Prompt）修改是否改善了推理？比较修改前后的痕迹。为什么Agent不断犯同样的错误？查看跨痕迹的模式。

## 这如何改变Agent的构建方式

当逻辑的“事实来源”从代码转移到痕迹时，其他一切也随之改变。你过去在代码上进行的所有操作——调试、测试、优化、监控——现在都需要以痕迹为中心。让我们看看这在实践中意味着什么。

### 调试变为痕迹分析

当用户报告“Agent失败了”，你不会打开代码寻找bug。你会打开痕迹，寻找推理出错的地方。是Agent误解了任务？调用了错误的工具？陷入了循环？

“Bug”不是你代码中的逻辑错误，而是Agent实际行为中的推理错误。

示例：一个Agent在放弃前不断重试同一个失败的API调用五次。你的代码有重试逻辑——这工作正常。Bug在于Agent没有从错误信息中学习。你只能在痕迹中看到这一点：相同的工具调用、相同的参数、相同的失败，不断重复。

### 你无法在推理中设置断点

在传统软件中，当你发现一个bug时，你在代码中设置一个断点。

在AI Agent中，你无法在推理中设置断点。决策发生在模型内部。

但是，你可以使用痕迹+Playground在“逻辑”中设置断点。在特定时间点（就在Agent做出错误决策之前）打开一个痕迹。将该确切状态加载到Playground中。Playground就像一个调试器，但针对的是推理而非代码。

你可以看到：Agent当时有什么上下文？它的记忆中有什么？有哪些工具可用？提示词是什么样的？然后你进行迭代——调整提示词、改变上下文、尝试不同的方法——看看Agent是否能做出更好的决策。

### 测试变为评估驱动

既然逻辑的“事实来源”在痕迹中，你需要测试这些痕迹。这意味着两件事：

第一：你需要一个流水线，将痕迹添加到你的测试数据集中。当你的Agent运行时，你捕获痕迹并将其添加到一个数据集中，以便进行后续评估。

第二：你需要在生产环境中评估痕迹。在传统软件中，你在部署前进行测试然后发布。在AI中，Agent是非确定性的，因此你需要在生产环境中持续评估，以捕捉质量下降和漂移。

### 性能优化方式改变

在传统软件中，你分析代码以找到热点循环并优化算法。在AI Agent中，你分析痕迹以找到决策模式——不必要的工具调用、冗余的推理、低效的路径。瓶颈在于Agent的决策，而这些只存在于痕迹中。

### 监控从正常运行时间转向质量

一个Agent可以“正常运行”且零错误，但表现仍然很差——成功完成了错误的任务、以10倍的成本低效地成功、或给出正确但无用的答案。

你需要监控决策的“质量”，而不仅仅是系统健康度——任务成功率、推理质量、工具使用效率。如果不采样和分析痕迹，你就无法监控质量。

### 协作转向可观测性平台

在传统软件中，协作发生在GitHub上。你审查代码、在PR上留下评论、在Issue中讨论实现。代码是每个人共同工作的工件。

在AI Agent中，逻辑不在代码里——它在痕迹里。因此，协作也必须发生在痕迹所在的地方。当然，你仍然使用GitHub来管理编排代码。但是，当你调试Agent为何做出错误决策时，你需要分享一个痕迹、在特定的决策点上添加评论、讨论它为何选择这条路径。你的可观测性平台变成了一个协作工具，而不仅仅是一个监控工具。

### 产品分析与调试融合

在传统软件中，产品分析与调试是分开的。Mixpanel告诉你用户点击了什么。你的错误日志告诉你什么出错了。它们是针对不同问题的不同工具。

在AI Agent中，这些融合了。不理解Agent的行为，就无法理解用户行为。当你在分析中看到“30%的用户感到沮丧”时，你需要打开痕迹看看Agent做错了什么。当你看到“用户请求数据分析功能”时，你需要查看痕迹，看看Agent已经在选择哪些工具以及什么在起作用。用户体验就是Agent的决策，而这些决策记录在痕迹中——因此产品分析必须建立在痕迹之上。

在传统软件中，代码是你的文档。在AI Agent中，痕迹是你的文档。

这种转变很简单：当决策逻辑从你的代码库转移到模型时，你的“事实来源”就从代码转移到了痕迹。

要实现这一点，你需要良好的可观测性。需要能够搜索、筛选和比较的结构化追踪能力。能够查看完整的推理链——调用了哪些工具、各步骤耗时、成本多少。能够对历史数据运行评估，以监控长期质量。

如果你正在构建Agent（智能体）却没有这些，那你就是在盲目工作。真正重要的逻辑只存在于那些追踪记录中。

来自LangChain团队和社区的更新

正在处理您的申请...

成功！请检查您的收件箱并点击链接确认订阅。

抱歉，出现错误。请重试。

![Agent框架、运行时与工具集——我的天！](/images/posts/2110bc77a378.png)

## Agent框架、运行时与工具集——我的天！

![构建LangChain三年的思考](/images/posts/db54a6ec9ac0.png)

## 构建LangChain三年的思考

![并非又一个工作流构建器](/images/posts/ff5166a3c3c8.webp)

## 并非又一个工作流构建器

![深度Agent](/images/posts/2622ee2805cf.png)

![“上下文工程”的兴起](/images/posts/8f8fb83ca2c7.jpg)

## “上下文工程”的兴起

![如何以及何时构建多Agent系统](/images/posts/eab0683a74e4.png)

## 如何以及何时构建多Agent系统

---

> 本文由AI自动翻译，原文链接：[In software, the code documents the app. In AI, the traces do.](https://blog.langchain.com/in-software-the-code-documents-the-app-in-ai-the-traces-do/)
> 
> 翻译时间：2026-01-11 04:44
