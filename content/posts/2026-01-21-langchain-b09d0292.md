---
title: 使用Deep Agents构建多智能体应用：子智能体与技能详解
title_original: Building Multi-Agent Applications with Deep Agents
date: '2026-01-21'
source: LangChain Blog
source_url: https://blog.langchain.com/building-multi-agent-applications-with-deep-agents/
author: ''
summary: 本文介绍了如何使用Deep Agents框架构建多智能体系统，重点讲解了子智能体（subagents）和技能（skills）两个核心原语。子智能体通过将任务委托给独立的智能体来解决上下文膨胀问题，实现专业化、并行化和多模型部署。文章详细说明了子智能体的使用场景、创建方法、最佳实践，并介绍了通用子智能体的应用。
categories:
- AI产品
tags:
- 多智能体系统
- Deep Agents
- 上下文管理
- AI工程
- 智能体架构
draft: false
translated_at: '2026-02-04T04:19:50.956878'
---

作者：Sydney Runkle 与 Vivek Trendy

将复杂任务分解给专门的智能体（Agent）是构建强大AI系统最有效的方法之一。

Deep Agents 通过两个一等公民（first-class）的原语让这一切变得简单：

- **子智能体（subagents）**：将任务委托给独立的智能体
- **技能（skills）**：渐进式地披露能力

在这篇文章中，我们将向你展示如何使用 Deep Agents 构建多智能体系统。

## 使用子智能体：专业化、独立的工作单元

子智能体解决了智能体工程中的一个基本问题：**上下文膨胀（context bloat）**。这是指智能体在处理任务时，其上下文窗口（Context Window）接近被填满的情况。

为什么这很重要？Chroma 关于**上下文腐化（context rot）** 的出色研究表明，当模型的上下文窗口被填满时，它们难以完成任务。我们在 HumanLayer 的朋友将这种高上下文状态称为“愚钝区（dumb zone）”。子智能体将上下文与主智能体隔离，有助于避免快速进入“愚钝区”。

当你的智能体进行数十次网络搜索或文件读取时，上下文窗口会被中间结果填满。子智能体通过在自己的上下文窗口中运行来隔离工作。因此，即使子智能体在得出最终答案前做了大量探索性工作，主智能体仍然只得到最终结果，而不是产生这个结果的 20 个工具调用。

以下是基本的子智能体架构概览：

![](/images/posts/36ccfee1171e.png)

### 何时使用子智能体

- **上下文保持（Context Preservation）**：需要多个步骤的任务可能会弄乱主智能体的上下文（例如：代码库探索）。
- **专业化（Specialization）**：使用特定领域的指令或工具。由不同团队开发的子智能体可以专注于不同的垂直领域。
- **多模型（Multi-Model）**：子智能体可以使用与主智能体不同的模型。例如，选择更小的模型以降低延迟。
- **并行化（Parallelization）**：子智能体可以同时运行，并将输出返回给主智能体。这可以减少延迟。

### 创建子智能体

将子智能体定义为字典并传递给 `create_deep_agent()`：

```python
from deepagents import create_deep_agent

research_subagent = {
    "name": "research-agent",
    "description": "用于深入研究问题",
    "system_prompt": "你是一名出色的研究员",
    "tools": [internet_search],
    "model": "openai:gpt-4o",  # 可选：覆盖主智能体模型
}

agent = create_deep_agent(
    model="claude-sonnet-4-5-20250929",
    subagents=[research_subagent]
)

```

有关配置详情，请参阅 `subagents` 文档。

### 通用子智能体

Deep Agents 包含一个内置的**通用（general-purpose）** 子智能体，它镜像了主智能体的能力。它具有相同的系统提示词（system prompt）、工具和模型。这非常适合**在不改变专业行为的情况下实现上下文隔离**。

示例：与其让主智能体进行 10 次网络搜索并填满其上下文，不如让它通过 `task(name="general-purpose", task="Research quantum computing trends")` 委托给通用子智能体。子智能体在内部执行所有搜索，并仅返回一个摘要。

### 子智能体的最佳实践

**编写清晰的描述。** 你的主智能体使用描述来决定调用哪个子智能体：

✅ 好："分析财务数据并生成带有置信度评分的投资见解"
❌ 差："处理财务相关事务"

**保持系统提示词详细。** 包含工具使用指导和输出格式要求：

```python
research_subagent = {
    "name": "research-agent",
    "description": "使用网络搜索进行深入研究并综合发现",
    "system_prompt": """你是一名细致的研究员。你的工作是：

    1. 将研究问题分解为可搜索的查询
    2. 使用 internet_search 查找相关信息
    3. 将发现综合成全面但简洁的摘要
    4. 提出主张时引用来源

    输出格式：
    - 摘要（2-3段）
    - 关键发现（要点列表）
    - 来源（附URL）

    请将回复控制在 500 字以内，以保持上下文简洁。""",
    "tools": [internet_search],
}

```

**最小化工具集。** 只给予智能体它们需要的工具：

```python
# ✅ 好：专注的工具集
email_agent = {
    "name": "email-sender",
    # 仅与邮件相关
    "tools": [send_email, validate_email],
}

# ❌ 差：工具过多
email_agent = {
    "name": "email-sender",
    # 不专注
    "tools": [send_email, web_search, database_query, file_upload],
}

```

## 使用技能：能力的渐进式披露

技能提供了一种不同的模式：**渐进式披露（progressive disclosure）**。与其一开始就给你的智能体几十个工具，不如在 `SKILL.md` 文件中定义专门的能力。你的智能体看到技能名称和描述，然后只在需要时才读取完整的指令。

![技能描述会预加载到上下文窗口中。技能主体仅在智能体根据描述和先前上下文判断需要该技能时才被加载。](/images/posts/d5620e8e1f33.png)

图注：技能描述会预加载到上下文窗口中。技能主体仅在智能体根据描述和先前上下文判断需要该技能时才被加载。

### 设置技能

技能遵循 `agentskills.io` 规范。以下是其结构：

```
.deepagents/skills/
├── deploy/SKILL.md
└── review-pr/SKILL.md

```

每个 `SKILL.md` 文件都包含带有元数据的 YAML 前言和主体部分：

```markdown
---
name: deploy
description: 部署到生产环境
version: 1.0.0  # 可选
tags: [deployment, production]  # 可选
---

# 部署到生产环境

当用户要求部署时，请遵循以下步骤：

1. 运行测试：`npm test`
2. 构建应用：`npm run build`
3. 部署到生产环境：`npm run deploy:prod`
4. 验证部署：检查健康端点

部署到生产环境前务必与用户确认。

```

### 为你的智能体添加技能

使用 `create_deep_agent` 的 `skills` 参数从文件系统加载技能：

```python
from deepagents import create_deep_agent
from deepagents.backends import FilesystemBackend

agent = create_deep_agent(
    model="claude-sonnet-4-5-20250929",
    backend=FilesystemBackend(root_dir="/"),
    skills=[".deepagents/skills"],
)

```

现在智能体可以看到你的技能了。当它需要详细指令时，它会读取完整的 `SKILL.md` 文件。

你也可以使用其他后端（例如 `StateBackend` 或 `StoreBackend`），然后通过 `files` 规范调用智能体：

```python
from deepagents.middleware.filesystem import FileData

# 默认后端是 StateBackend
agent = create_deep_agent(
    model="anthropic:claude-sonnet-4-20250514",
    skills=["/skills/"],
)

skill_content = """
---
name: deploy
...
"""

# 使用技能和虚拟文件调用智能体
result = agent.invoke({
    "messages": [HumanMessage(content="Research the latest Python releases")],
    "files": {
        "/skills/web-research/SKILL.md": FileData(
            content=skill_content.split("\n"),
            created_at="2024-01-01T00:00:00Z",
            modified_at="2024-01-01T00:00:00Z",
        ),
    },
})

```

## 选择正确的模式

以下是一组快速问题来指导你：

## 后续步骤

要了解更多关于 Deep Agents 中的多智能体模式，请查看我们的：

- **子智能体文档** - 详细的 API 参考和示例
- **技能文档** - 详细的 API 参考和示例
- **多智能体模式指南** - 关于选择模式的一般指导

关键见解：多智能体模式不必复杂。借助正确的抽象（用于管道的中间件，用于调用的工具调用），它们可以成为简单的构建块，你可以将它们组合成强大、复杂的系统。

从用于上下文管理的子智能体开始，添加用于渐进式披露的技能，并在此基础上进行构建。

### 加入我们的新闻通讯

来自 LangChain 团队和社区的更新

正在处理您的申请...

成功！请检查您的收件箱并点击链接确认订阅。

抱歉，出错了。请重试。

---

> 本文由AI自动翻译，原文链接：[Building Multi-Agent Applications with Deep Agents](https://blog.langchain.com/building-multi-agent-applications-with-deep-agents/)
> 
> 翻译时间：2026-02-04 04:19
