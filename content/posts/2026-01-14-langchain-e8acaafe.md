---
title: 如何选择多智能体架构：四种核心模式解析
title_original: Choosing the Right Multi-Agent Architecture
date: '2026-01-14'
source: LangChain Blog
source_url: https://www.blog.langchain.com/choosing-the-right-multi-agent-architecture/
author: ''
summary: 本文探讨了何时需要采用多智能体架构，并详细介绍了四种主要模式：子智能体（集中式编排）、技能（渐进式披露）、交接和路由器。文章指出，当面临上下文管理限制或需要跨团队分布式开发时，多智能体系统能显著提升性能，例如研究显示其表现可比单智能体高出90.2%。作者建议从单智能体入手，在复杂度增加时根据具体约束选择合适的架构模式。
categories:
- AI研究
tags:
- 多智能体系统
- AI架构
- LangChain
- 智能体协作
- 上下文管理
draft: false
translated_at: '2026-01-15T04:40:44.228283'
---

# 选择正确的多智能体架构

在本文中，我们将探讨何时需要多智能体架构、我们观察到的四种主要模式，以及 LangChain 如何赋能您有效构建多智能体系统。

许多智能体任务最好由配备精心设计工具的单个智能体来处理。您应该从这里开始——单智能体更易于构建、推理和调试。但随着应用规模的扩大，团队面临一个共同的挑战：他们拥有大量希望整合到单一连贯界面中的智能体能力。当希望整合的功能数量增加时，两个主要约束就会出现：

**上下文管理**：每个能力的专业知识无法舒适地放入单个提示词中。如果上下文窗口是无限的且延迟为零，您可以预先包含所有相关信息。但在实践中，您需要策略来在智能体工作时选择性地呈现信息。

**分布式开发**：不同的团队独立开发和维护每个能力，具有清晰的边界和所有权。一个单一、庞大的智能体提示词在跨团队边界时变得难以管理。

当您管理广泛领域知识、跨团队协调或处理真正复杂的任务时，这些约束变得至关重要。在这些情况下，多智能体架构可能成为正确的选择。

**最近的研究**证明了多智能体系统在这些情况下表现更优。在 Anthropic 的多智能体研究系统中，一个以 Claude Opus 4 为主导智能体、Claude Sonnet 4 为子智能体的多智能体架构，在内部研究评估中比单智能体 Claude Opus 4 高出 90.2%。该架构能够将工作分配给具有独立上下文窗口的智能体，实现了单智能体无法达成的并行推理。

## 多智能体架构

四种架构模式构成了大多数多智能体应用的基础：子智能体、技能、交接和路由器。每种模式在任务协调、状态管理和顺序解锁方面采取不同的方法。下面我们概述了一个选择最适合解决您最关键约束的架构的框架。

### 子智能体：集中式编排

在子智能体模式中，一个监督智能体通过将专门的子智能体作为工具调用来协调它们。主智能体维护对话上下文，而子智能体保持无状态，提供了强大的上下文隔离。

**工作原理**：主智能体决定调用哪些子智能体、提供什么输入以及如何组合结果。子智能体不记得过去的交互。这种架构提供了集中控制，所有路由都通过主智能体进行，主智能体可以并行调用多个子智能体。

**最适合**：具有多个不同领域的应用，需要集中式工作流控制，且子智能体无需直接与用户对话。例如，协调日历、电子邮件和 CRM 操作的个人助理，或委托给特定领域专家的研究系统。

**关键权衡**：每次交互增加一次额外的模型调用，因为结果必须流回主智能体。这种开销提供了集中控制和上下文隔离，但代价是延迟和 Token 消耗。

对于希望以最少设置实现此模式的开发者，**Deep Agents** 提供了一个开箱即用的实现，只需几行代码即可添加子智能体。

**了解更多**：[子智能体文档](https://python.langchain.com/docs/how_to/multi_agent_subagents/) | [教程：使用子智能体构建个人助理](https://python.langchain.com/docs/tutorials/multi_agent_subagents/)

### 技能：渐进式披露

在技能模式中，智能体按需加载专门的提示词和知识。可以将其视为智能体能力的渐进式披露。

虽然技能架构在技术上使用单个智能体，但它通过使该智能体能够动态采用专门的角色，具备了多智能体系统的特征。这种方法提供了与多智能体模式类似的好处——如分布式开发和细粒度上下文控制——但通过更轻量级、提示驱动的方法实现，而不是管理多个智能体实例。因此，或许存在争议，我们认为技能是一种准多智能体架构。

**工作原理**：技能主要是提示驱动的专业化能力，打包为包含指令、脚本和资源的目录。在启动时，智能体只知道技能名称和描述。当某个技能变得相关时，智能体加载其完整上下文。技能内的附加文件提供了第三层细节，智能体仅在需要时发现。

**最适合**：具有许多可能专业化的单智能体、不需要在能力之间强制执行约束的情况，或不同团队维护不同技能的团队分布场景。常见示例包括编码智能体或创意助手。

**关键权衡**：随着技能的加载，上下文会在对话历史中累积，这可能导致后续调用的 Token 膨胀。然而，该模式提供了简单性和贯穿始终的直接用户交互。

**了解更多**：[技能文档](https://python.langchain.com/docs/how_to/multi_agent_skills/) | [教程：使用按需技能构建 SQL 助手](https://python.langchain.com/docs/tutorials/multi_agent_skills/)

### 交接：状态驱动的转换

在交接模式中，活跃智能体根据对话上下文动态变化。每个智能体都能够通过工具调用转移到其他智能体。

**工作原理**：当智能体调用交接工具时，它会更新决定下一个激活智能体的状态。这可能意味着切换到不同的智能体，或更改当前智能体的系统提示词和可用工具。状态在对话轮次间持续存在，从而实现顺序工作流。

**最适合**：分阶段收集信息的客户支持流程、多阶段对话体验，或任何需要顺序约束、能力仅在满足前提条件后解锁的场景。

**关键权衡**：比其他模式更具状态性，需要仔细的状态管理。然而，这使得流畅的多轮对话成为可能，上下文在阶段之间自然延续。

**了解更多**：[交接文档](https://python.langchain.com/docs/how_to/multi_agent_handoffs/) | [教程：使用交接构建客户支持](https://python.langchain.com/docs/tutorials/multi_agent_handoffs/)

### 路由器：并行分发与合成

在路由器模式中，路由步骤对输入进行分类并将其定向到专门的智能体，并行执行查询并合成结果。

**工作原理**：路由器分解查询，并行调用零个或多个专门的智能体，并将结果合成为连贯的响应。路由器通常是无状态的，独立处理每个请求。

**最适合**：具有不同垂直领域（独立知识领域）的应用、需要并行跨多个源查询的场景，或需要从多个智能体合成结果的情况。示例包括企业知识库和多垂直领域客户支持助手。

**关键权衡**：无状态设计意味着每个请求的性能一致，但如果需要对话历史，则会产生重复的路由开销。可以通过将路由器包装为有状态对话智能体内的工具来缓解。

**了解更多**：[路由器文档](https://python.langchain.com/docs/how_to/multi_agent_router/) | [教程：使用路由构建多源知识库](https://python.langchain.com/docs/tutorials/multi_agent_router/)

## 将需求与模式匹配

在实现多智能体系统之前，请考虑您的需求是否与以下四种模式之一相符：

**下表**显示了每种模式如何支持常见的多智能体需求：

- **分布式开发**：不同团队能否独立维护组件？
- **并行化**：多个Agent能否并发执行？
- **多跳调用**：该模式是否支持串联调用多个子Agent？
- **直接用户交互**：子Agent能否直接与用户对话？

## 性能特征

架构选择直接影响延迟、成本和用户体验。我们分析了三种典型场景，以了解不同模式在实际条件下的表现。

注意：您可以在我们全新的[多Agent性能文档](链接)中查看完整的性能分析（包含每种架构的Mermaid图表）。

### 场景一：单次请求

用户提出单次请求：“购买咖啡”。一个专用Agent可以调用`buy_coffee`工具。

**关键发现**：对于单一任务，移交模式、技能模式和路由模式效率最高（各需3次调用）。子Agent模式因结果需流经主Agent而额外增加一次调用。如下所示，这种开销提供了集中控制能力。

### 场景二：重复请求

用户在对话中连续提出相同请求：
- 第一轮：“购买咖啡”
- 第二轮：“再买一次咖啡”

**关键发现**：有状态模式（移交模式、技能模式）通过保持上下文，在重复请求时可节省40-50%的调用次数。子Agent模式通过无状态设计保持每次请求的成本稳定，以重复模型调用为代价提供了强大的上下文隔离。

### 场景三：多领域查询

用户提问：“比较Python、JavaScript和Rust在Web开发中的表现”。每个语言Agent包含约2000个Token的文档。所有模式均可进行并行工具调用。

**关键发现**：对于多领域任务，支持并行执行的模式（子Agent模式、路由模式）效率最高。技能模式调用次数较少，但因上下文累积导致Token使用量较高。移交模式必须顺序执行，无法通过并行工具调用来同时咨询多个领域。

在此场景中，由于上下文隔离，子Agent模式整体处理的Token数量比技能模式少67%。每个子Agent仅处理相关上下文，避免了将多个技能加载到单一对话中时产生的Token膨胀问题。

最佳模式取决于您的工作负载特征：

多Agent系统通过协调专用组件来处理复杂工作流。当确实需要多Agent能力时，请根据上述决策框架匹配您的需求。对于希望快速入门的团队，[Deep Agents](链接)提供了结合子Agent与技能模式的即用型实现方案，适用于复杂任务规划。

但在多数情况下，更简单的架构往往已足够。建议从单Agent架构和良好的提示词工程开始。先添加工具，再考虑增加Agent。仅当遇到明确瓶颈时，才升级到多Agent模式。

来自LangChain团队和社区的更新

正在处理您的申请...

成功！请查收邮件并点击链接确认订阅。

抱歉，出现错误。请重试。

> 本文由AI自动翻译，原文链接：[Choosing the Right Multi-Agent Architecture](https://www.blog.langchain.com/choosing-the-right-multi-agent-architecture/)
> 
> 翻译时间：2026-01-15 04:40
