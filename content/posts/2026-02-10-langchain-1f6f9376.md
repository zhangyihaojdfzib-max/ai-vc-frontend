---
title: 智能体连接沙箱的两种架构模式
title_original: The two patterns by which agents connect sandboxes
date: '2026-02-10'
source: LangChain Blog
source_url: https://blog.langchain.com/the-two-patterns-by-which-agents-connect-sandboxes/
author: ''
summary: 本文探讨了智能体（Agent）与沙箱集成的两种核心架构模式。模式一为“智能体在沙箱内运行”，智能体在沙箱内部执行，通过网络与外部通信，其优势在于与本地开发环境一致，智能体与环境紧密耦合。模式二为“沙箱即工具”，智能体在外部运行，远程调用沙箱执行任务，其优势在于易于更新智能体逻辑、API密钥保留在沙箱外、职责分离更清晰。文章分析了两种模式的优缺点、适用场景及安全考量，并指出工具如deepagents已支持这两种配置。
categories:
- AI基础设施
tags:
- 智能体
- 沙箱
- 架构模式
- AI安全
- 开发环境
draft: false
translated_at: '2026-02-11T04:32:05.514637'
---

感谢 Witan Labs 的 Nuno Campos、E2B 的 Tomas Beran 和 Mikayel Harutyunyan、Runloop 的 Jonathan Wall 以及 Zo Computer 的 Ben Guo 的审阅和评论。

**太长不看版：**

*   越来越多的 Agent（智能体）需要一个工作空间：一台可以运行代码、安装软件包和访问文件的计算机。沙箱提供了这个空间。
*   将 Agent（智能体）与沙箱集成有两种架构模式：
    *   **模式 1（Agent IN Sandbox）**：Agent（智能体）在沙箱内运行，你通过网络与其通信。**优点**：与本地开发环境一致，Agent（智能体）与环境紧密耦合。
    *   **模式 2（Sandbox as Tool）**：Agent（智能体）在本地/你的服务器上运行，远程调用沙箱执行任务。**优点**：易于更新 Agent（智能体）逻辑，API 密钥保留在沙箱外，职责分离更清晰。
*   `deepagents` 通过简单配置支持这两种模式。

越来越多的 Agent（智能体）需要一个工作空间——一台可以运行代码、安装软件包和访问文件的计算机。这个工作空间需要被隔离，以防止 Agent（智能体）访问你的凭据、文件或网络。沙箱通过在 Agent（智能体）环境与你的主机系统之间创建边界来提供这种隔离。构建这些 Agent（智能体）的团队面临的问题不是**是否**使用沙箱，而是**如何**将沙箱集成到他们的 Agent（智能体）架构中。

根据 Agent（智能体）运行的位置，有两种常见模式：在沙箱内部或在沙箱外部。每种模式都有不同的优点和权衡。

**注意**：本文重点讨论为 Agent（智能体）提供完整“计算机”的沙箱——即完整的执行环境，如 Docker 容器或虚拟机。我们不涉及进程级沙箱（如 `bubblewrap`）或语言级沙箱（如 `Pyodide`）。

## 模式 1：Agent（智能体）在沙箱内运行

在这种模式下，Agent（智能体）在沙箱内部运行。你通过网络与其通信。

![](/images/posts/7f4fcc76c661.png)

实际应用中的样子：

你构建一个预装了 Agent（智能体）框架的 Docker 或虚拟机镜像，在沙箱内运行它，然后从外部连接以发送消息。Agent（智能体）暴露一个 API 端点（通常是 HTTP 或 WebSocket），你的应用程序跨沙箱边界与其通信。

**优点：**

这种模式与本地开发环境非常相似——如果你在本地终端运行 `deepagents`，你在沙箱内运行相同的命令。Agent（智能体）拥有直接的文件系统访问权限，并且可以修改其环境。当 Agent（智能体）和执行环境紧密耦合时，这很有用，例如当 Agent（智能体）需要与特定库交互或维护复杂的环境状态时。

**权衡：**

跨沙箱边界的通信需要基础设施。一些供应商在其 SDK 中处理这个问题——例如，像 OpenCode 这样的 Agent（智能体）在沙箱内运行一个服务器，而像 E2B 这样的供应商可以通过一个简洁的 API 将其暴露出来。如果你的供应商不提供此功能，你需要自己构建 WebSocket 或 HTTP 层，包括会话管理和错误处理。

API 密钥必须存放在沙箱内，以便 Agent（智能体）进行推理调用。如果沙箱被攻破（无论是通过隔离技术中的漏洞，还是通过提示词注入攻击泄露凭据），这会产生潜在的安全风险。**注意**：我们看到像 E2B 和 Runloop 这样的供应商正在开发密钥保险库功能，以解决这个问题。

更新需要重新构建容器镜像并重新部署，这会减慢开发期间的迭代周期。

另一个缺点是，在 Agent（智能体）变为活动状态之前，必须恢复沙箱，这通常需要额外的逻辑。

对于那些担心保护其 Agent（智能体）知识产权的人来说，如果你的 Agent（智能体）在沙箱中运行，那么窃取整个 Agent（智能体）代码和提示词会变得容易得多。

Witan Labs 的 Nuno Campos 也指出了另一个安全风险：“我认为 Agent（智能体）在沙箱内的另一个缺点是，实际上你的 Agent（智能体）的任何部分都不能拥有比 bash 工具更多的权限。例如，假设你想要一个拥有 bash 工具和可以进行网络搜索或网络抓取工具的 Agent（智能体），那么所有 LLM（大语言模型）生成的代码都可以进行无限的网络抓取（这是一个很大的安全风险）。如果是‘沙箱即工具’模式，那么你可以轻松地拥有比赋予 LLM（大语言模型）生成代码更多权限的工具（这对许多 Agent（智能体）来说听起来非常有用），因为安全边界是围绕 bash 工具的，而不是整个 Agent（智能体）。”

## 模式 2：沙箱即工具

在这种模式下，Agent（智能体）在你的机器或服务器上运行。当它需要执行代码时，它通过 API 调用远程沙箱。

![](/images/posts/aded739a73e9.png)

你的 Agent（智能体）在本地（或你的服务器上）运行，当它生成需要执行的代码时，它会调用沙箱供应商的 API（如 `E2B`、`Modal`、`Daytona` 或 `Runloop`）。供应商的 SDK 处理所有通信细节。从你的 Agent（智能体）的角度来看，沙箱只是另一个工具。

你可以即时更新 Agent（智能体）代码，而无需重新构建容器镜像，这加快了开发期间的迭代速度。API 密钥保留在沙箱外部——只有执行过程在隔离环境中进行。这提供了更清晰的职责分离：Agent（智能体）状态（对话历史、思维链、记忆）存放在你的 Agent（智能体）运行的地方，与沙箱分离。这意味着沙箱故障不会丢失你的 Agent（智能体）状态，并且你可以在不影响 Agent（智能体）核心逻辑的情况下切换沙箱后端。

正如 E2B 的 Tomas Beran 所指出的，这种选择还有另外两个好处：

1.  可以选择在多个远程沙箱中并行运行任务。
2.  仅在执行代码时为沙箱付费，而不是为整个进程运行时间付费。

Ben Guo 补充了关于将 Agent（智能体）运行时与沙箱运行时分离的好处的最后一点：“我们选择模式 2 的原因除了你提到的，还为了准备一个未来，即让 Agent（智能体）框架在 GPU 机器上运行变得有意义——通常感觉持久沙箱和推理框架的环境要求会有所不同。”

**网络延迟是主要的缺点。** 每次执行调用都需要跨越网络边界。对于有许多小规模执行的工作负载，这会累积起来。

许多沙箱供应商提供有状态的会话，其中变量、文件和已安装的软件包在同一会话内的多次调用之间保持持久性。这可以通过减少所需的往返次数来缓解一些延迟问题。

## 在模式之间选择

**在以下情况选择模式 1：**

*   Agent（智能体）和执行环境紧密耦合（例如，Agent（智能体）需要持久访问特定库或复杂的环境状态）
*   你希望生产环境与本地开发环境高度一致
*   你的供应商的 SDK 为你处理通信层

**在以下情况选择模式 2：**

*   你需要在开发期间快速迭代 Agent（智能体）逻辑
*   你希望将 API 密钥保留在沙箱外部
*   你更喜欢 Agent（智能体）状态和执行环境之间有更清晰的分离

## 实现示例

为了使这些模式更具体，我们将展示使用 `deepagents` 的示例，这是一个内置沙箱支持的开源 Agent（智能体）框架。类似的模式也适用于其他 Agent（智能体）框架。

### 模式 1：Agent（智能体）在沙箱内

对于模式 1，首先构建一个预装了你的 Agent（智能体）的镜像：

```docker
FROM python:3.11
RUN pip install deepagents-cli
```

然后在沙箱中运行它。完整的实现需要额外的基础设施来处理应用程序与沙箱内Agent（智能体）之间的通信（WebSocket或HTTP服务器、会话管理、错误处理）。这超出了本文的范围，但我们后续会有文章更详细地探讨这一点。

```python
from daytona import Daytona
from langchain_anthropic import ChatAnthropic

from deepagents import create_deep_agent
from langchain_daytona import DaytonaSandbox

# 也可以使用 E2B, Runloop, Modal 来实现
sandbox = Daytona().create()
backend = DaytonaSandbox(sandbox=sandbox)

agent = create_deep_agent(
    model=ChatAnthropic(model="claude-sonnet-4-20250514"),
    system_prompt="You are a Python coding assistant with sandbox access.",
    backend=backend,
)

result = agent.invoke(
    {
        "messages": [
            {
                "role": "user",
                "content": "Run a small python script",
            }
        ]
    }
)

sandbox.stop()


```

这段代码运行时会发生以下情况：

1.  Agent（智能体）在您的本地机器上进行规划
2.  它生成解决问题的Python代码
3.  它调用Runloop API，在远程沙箱中执行代码
4.  沙箱返回结果
5.  Agent（智能体）看到输出后，继续在本地进行推理

## 结论

出于安全考虑，Agent（智能体）需要在隔离环境中执行代码。有两种架构模式：在沙箱内运行Agent（智能体）（模拟本地开发，紧密耦合）或在沙箱外运行，将沙箱作为工具（易于更新，API密钥保持安全）。根据您的需求，每种模式都有不同的优势和权衡。

deepagents通过简单的配置支持这两种模式。尝试一下，看看哪种模式最适合您的用例。

### 加入我们的新闻通讯

来自LangChain团队和社区的更新

正在处理您的申请...

成功！请检查您的收件箱并点击链接确认订阅。

抱歉，出错了。请再试一次。

---

> 本文由AI自动翻译，原文链接：[The two patterns by which agents connect sandboxes](https://blog.langchain.com/the-two-patterns-by-which-agents-connect-sandboxes/)
> 
> 翻译时间：2026-02-11 04:32
