---
title: Vercel如何打造原生体验的v0 iOS应用
title_original: How we built the v0 iOS app - Vercel
date: '2025-11-24'
source: Vercel Blog
source_url: https://vercel.com/blog/how-we-built-the-v0-ios-app
author: ''
summary: 本文详细介绍了Vercel团队开发其首款移动应用v0 iOS版的技术历程。作为一家以Web为核心的公司，团队在探索原生应用开发时，以苹果设计奖为标准，尝试了多种技术栈和UI模式。最终选择React
  Native与Expo框架，重点构建了流畅的AI聊天体验，包括可组合的聊天架构、平滑的消息动画、原生键盘控制、浮动输入框以及Web与原生代码共享等关键技术实现。文章分享了在移动端实现AI代码生成交互的创新模式与解决方案。
categories:
- AI产品
tags:
- React Native
- 移动开发
- Vercel
- AI聊天界面
- 用户体验
draft: false
translated_at: '2026-01-07T13:05:36.887285'
---

我们最近发布了 iOS 版 `v0`，这是 Vercel 的首款移动应用。作为一家专注于网络的公司，构建原生应用对我们来说是一个全新的领域。

我们的目标是构建一款配得上苹果设计奖的应用，并且我们对实现这一目标的最佳技术栈持开放态度。为此，我们在公开测试版之前构建了数十个产品迭代版本。我们尝试了截然不同的技术栈和 UI 模式。

我们从那些体现 iPhone 设计语言的应用中汲取灵感，例如苹果备忘录和 iMessage。`v0` 必须在你的主屏幕上与这些优秀应用并列，赢得一席之地。

经过数周的实验，我们最终选择了 React Native 与 Expo 来实现这一目标。我们对结果感到满意，我们的客户也是如此。事实上，大量开发者询问这款应用为何感觉如此原生，这促使我们撰写一篇技术解析文章，详细说明我们是如何做到的。

## 目录

*   `v0` 聊天体验的构建方式
    *   构建可组合的聊天
    *   发送你的第一条消息
    *   淡入第一条助手消息
    *   在现有聊天中发送消息
    *   我们如何解决消息滚动到顶部的问题
*   键盘控制
*   初始滚动到底部
*   浮动输入框
    *   使其浮动
    *   使其原生
    *   粘贴图片
*   内容淡入效果
*   在 Web 与原生平台间共享代码
*   样式设计
    *   原生菜单
    *   原生警告框
    *   原生底部操作表
*   展望未来

`v0` 聊天体验的构建方式

*   构建可组合的聊天
*   发送你的第一条消息
*   淡入第一条助手消息
*   在现有聊天中发送消息
*   我们如何解决消息滚动到顶部的问题

构建可组合的聊天

发送你的第一条消息

淡入第一条助手消息

在现有聊天中发送消息

我们如何解决消息滚动到顶部的问题

初始滚动到底部

*   使其浮动
*   使其原生
*   粘贴图片

在 Web 与原生平台间共享代码

*   原生菜单
*   原生警告框
*   原生底部操作表

## `v0` 聊天体验的构建方式

当你离开电脑时，可能突然有个想法想要付诸实践。我们的目标是让你无需切换上下文，就能将这个想法转化为具体的东西。iOS 版 `v0` 是你备忘录应用的下一代产品，你的想法将在后台被构建出来。

我们并非要构建一个与网站功能对等的移动 IDE。相反，我们想构建一个简单、愉悦的体验，让你能在移动中使用 AI 来创造东西。这个体验的核心就是聊天。

为了构建一个出色的聊天功能，我们设定了以下要求：

*   新消息平滑地以动画形式进入
*   新的用户消息滚动到屏幕顶部
*   助手消息在流式传输时以交错过渡的方式淡入
*   输入框使用液态玻璃效果并浮动在可滚动内容之上
*   打开现有聊天时，初始位置滚动到底部
*   键盘处理感觉自然
*   文本输入框允许粘贴图片和文件
*   文本输入框支持平移手势来聚焦和失焦
*   Markdown 渲染快速且支持动态组件

新消息平滑地以动画形式进入

新的用户消息滚动到屏幕顶部

助手消息在流式传输时以交错过渡的方式淡入

输入框使用液态玻璃效果并浮动在可滚动内容之上

打开现有聊天时，初始位置滚动到底部

键盘处理感觉自然

文本输入框允许粘贴图片和文件

文本输入框支持平移手势来聚焦和失焦

Markdown 渲染快速且支持动态组件

虽然移动应用中已经出现了一些用于 AI 聊天的 UI 模式，但在移动端进行 AI 代码生成方面，还没有一套对等的模式。

我们在现有的 React Native 应用中没有见过这些功能，因此我们发现自己需要即时发明模式。为了让每个功能都达到我们的标准，我们投入了大量的工作、测试和协调。

## 构建可组合的聊天

为了满足我们的要求，我们将聊天代码结构设计为**可组合的**，基于每个功能。

我们的聊天功能由几个开源库驱动：LegendList、React Native Reanimated 和 React Native Keyboard Controller。首先，我们设置了多个上下文提供者。

```
1export function ChatProvider({ children }) {2  return (3    <ComposerHeightProvider>4      <MessageListProvider>5        <NewMessageAnimationProvider>6          <KeyboardStateProvider>{children}</KeyboardStateProvider>7        </NewMessageAnimationProvider>8      </MessageListProvider>9    </ComposerHeightProvider>10  )11}
```

该提供者包裹着 `MessagesList`：

```
1export function ChatMessagesList({ chatId }) {2  const messages = useMessages({ chatId }).data3  return (4    <ChatProvider key={chatId}>5      <MessagesList messages={messages} />6    </ChatProvider>7  )8}
```

接下来，我们的消息列表将这些功能实现为可组合的插件，每个插件都有自己的钩子。

```
1function MessagesList({ messages }) {2  useKeyboardAwareMessageList()3  useScrollMessageListFromComposerSizeUpdates()4  useUpdateLastMessageIndex()5  const { animatedProps, ref, onContentSizeChange, onScroll } = useMessageListProps()6  return (7    <AnimatedLegendList8      animatedProps={animatedProps}9      ref={ref}10      onContentSizeChange={onContentSizeChange}11      onScroll={onScroll}12      enableAverages={false}13      data={messages}14      keyExtractor={(item) => item.id}15      renderItem={({ item, index }) => {16        if (item.role === 'user') {17          return <UserMessage message={item} index={index} />18        }19        if (item.role === 'assistant') {20          return <AssistantMessage message={item} index={index} />21        }22        if (item.role === 'optimistic-placeholder') {23          return <OptimisticAssistantMessage index={index} />24        }25      }}26    />27  )28}
```

以下部分将分解每个钩子，以演示它们如何协同工作。

## 发送你的第一条消息

当你在 `v0` 上发送消息时，消息气泡会平滑地淡入并滑动到顶部。在用户消息动画完成后，助手消息会立即淡入。

当用户发送消息时，我们设置一个 Reanimated 共享值来指示动画应该开始。共享值允许我们更新状态而不触发重新渲染。

```
1const { isMessageSendAnimating } = useNewMessageAnimation()2const chatId = useChatId()3
4const onSubmit = () => {5  const isNewChat = !chatId6  7  if (isNewChat) {8    isMessageSendAnimating.set(true)9  }10  11  send()12}
```

在提交时设置动画状态

由于我们的状态由 Reanimated 跟踪，我们现在可以为 `UserMessage` 添加动画。

```
1export function UserMessage({ message, index }) {2  const isFirstUserMessage = index === 03  4  const { style, ref, onLayout } = useFirstMessageAnimation({5    disabled: !isFirstUserMessage,6  })7  8  return (9    <Animated.View style={style} ref={ref} onLayout={onLayout}>10      <UserMessageContent message={message} />11    </Animated.View>12  )13}
```

将用户消息包裹在动画视图中

注意，`UserMessageContent` 被包裹在一个 `Animated.View` 中，该视图接收来自 `useFirstMessageAnimation` 的属性。

### `useFirstMessageAnimation` 的工作原理

这个钩子负责三件事：

1.  使用 Reanimated 共享值 `itemHeight` 测量用户消息的高度
2.  当 `isMessageSendAnimating` 为真时淡入消息
3.  向助手消息发出动画完成的信号

使用 Reanimated 共享值 `itemHeight` 测量用户消息的高度

当 `isMessageSendAnimating` 为真时淡入消息

向助手消息发出动画完成的信号

```
1export function useFirstMessageAnimation({ disabled }) {2  const { keyboardHeight } = useKeyboardContextState()3  const { isMessageSendAnimating } = useNewMessageAnimation()4  const windowHeight = useWindowDimensions().height5  const translateY = useSharedValue(0)6  const progress = useSharedValue(-1)7  const { itemHeight, ref, onLayout } = useMessageRenderedHeight()8
9  useAnimatedReaction(10    () => {11      const didAnimate = progress.get() !== -112
13      if (disabled || didAnimate || !isMessageSendAnimating.get()) {14        return -115      }16
17      return itemHeight.get()18    },19    (messageHeight) => {20      if (messageHeight <= 0) return21
22      const animatedValues = getAnimatedValues({23        itemHeight: messageHeight,24        windowHeight,25        keyboardHeight: keyboardHeight.get(),26      })27      const { start, end, duration, easing, config } = animatedValues28
29      translateY.set(30        // 以持续时间为0的"起始"状态初始化值31        withTiming(start.translateY, { duration: 0 }, () => {32          // 接着，过渡到"结束"状态33          translateY.set(withSpring(end.translateY, config))34        })35      )36      progress.set(37        withTiming(start.progress, { duration: 0 }, () => {38          progress.set(withTiming(end.progress, { duration, easing }), () => {39            isMessageSendAnimating.set(false)40          })41        })42      )43    }44  )45
46  const style = useAnimatedStyle(...)47  const didUserMessageAnimate = useDerivedValue(() => progress.get() === 1)48  49  return { style, ref, onLayout, didUserMessageAnimate }50}
```

useFirstMessageAnimation 钩子

得益于 React Native 的新架构，`useLayoutEffect` 中的 `ref.current.measure()` 是同步的，这让我们能在首次渲染时获取高度。后续的更新则在 `onLayout` 中触发。

基于消息高度、窗口高度和当前键盘高度，`getAnimatedValues` 为 `translateY` 和 `progress` 构建了缓动函数、起始状态和结束状态。生成的共享值分别作为 `transform` 和 `opacity` 传递给 `useAnimatedStyle`。

就这样，我们的第一条消息使用 Reanimated 淡入。一旦动画完成，我们就可以淡入第一条助手消息回复了。

## 链接到标题淡入第一条助手消息

与 `UserMessage` 类似，助手消息内容被包裹在一个动画视图中，该视图在用户消息动画完成后淡入。

```
1function AssistantMessage({ message, index }) {2  const isFirstAssistantMessage = index === 13  4  const { didUserMessageAnimate } = useFirstMessageAnimation({5    disabled: !isFirstAssistantMessage,6  })7
8  const style = useAnimatedStyle(() => ({9    opacity: didUserMessageAnimate.get() ? withTiming(1, { duration: 350 }) : 0,10  }))11  12  return (13    <Animated.View style={style}>14      <AssistantMessageContent message={message} />15    </Animated.View>16  )17}
```

在用户消息动画完成后淡入

这种淡入行为仅针对聊天中的第一条助手消息启用，即 `index === 1`。现有聊天中的消息行为将与新聊天中的消息不同。

如果你打开一个已有一条用户消息和一条助手消息的现有聊天，它会再次执行淡入动画吗？不会，因为这里的动画仅在 `isMessageSendAnimating` 为 `true` 时应用，而该值在 `onSubmit` 时设置，并在你切换聊天时清除。

## 链接到标题在现有聊天中发送消息

我们已经介绍了 `v0` 如何处理新聊天中消息的动画。然而，对于现有聊天，逻辑则完全不同。我们不依赖 Reanimated 动画（例如 `useFirstMessageAnimation` 中的动画），而是依赖 `scrollToEnd()` 的实现。

那么，如果我们在现有聊天中发送消息，只需要滚动到底部，对吗？

```
1useEffect(function onNewMessage() {2  const didNewMessageSend = // ...一些逻辑3  if (didNewMessageSend) {4    listRef.current?.scrollToEnd()5  }6}, ...)
```

在理想情况下，这就是我们所需的全部逻辑。让我们探讨一下为什么这还不够。

如果你还记得引言部分，我们的一个要求是新消息必须滚动到屏幕顶部。如果我们简单地调用 `scrollToEnd()`，那么新消息将显示在屏幕底部。

![](/images/posts/0219303ba7ee.png)

![](/images/posts/4ac7048e5df1.png)

我们需要一种策略将用户消息推到聊天顶部。我们称之为“空白区域大小”：即最后一条助手消息底部与聊天末尾之间的距离。

![](/images/posts/e5ced9864aae.png)

![](/images/posts/d36f75d8dcb5.png)

为了让内容浮动到聊天顶部，我们必须将其向上推一个等于空白区域大小的距离。得益于 React Native 新架构中的同步高度测量，这可以在每一帧上实现且无闪烁。但这仍然需要很多技巧和协调。

在上图中，你会注意到空白区域大小是动态的。它的高度取决于键盘的打开状态。并且它可能在每次渲染时都发生变化，因为助手消息快速流入且大小不可预测。

动态高度是虚拟化列表中的常见挑战。频繁更新的空白区域大小将这一挑战提升到了新的高度。我们的列表项具有动态、未知且频繁更新的高度，我们需要它们浮动到顶部。

对于足够长的助手消息，空白区域大小可能为零，这又引入了一系列新的边界情况。

![](/images/posts/0ad473fbeb9c.png)

![](/images/posts/4491fb1ebd3d.png)

## 链接到标题我们如何解决它

我们尝试了许多不同的方法来实现空白区域大小。我们尝试在 `ScrollView` 底部放置一个具有高度的 `View`，在 `ScrollView` 本身设置底部内边距，对可滚动内容使用 `translateY`，以及对最后一条系统消息设置最小高度。所有这些方法最终都产生了奇怪的副作用和较差的性能，通常是由于需要与 Yoga 进行布局。

我们最终确定了一个解决方案，该方案使用 `ScrollView` 上的 `contentInset` 属性来处理空白区域大小，且无抖动。`contentInset` 直接映射到 UIKit 中 `UIScrollView` 的原生属性。

然后，我们在发送消息时，将 `contentInset` 与 `scrollToEnd({ offset })` 配对使用。

助手消息的空白区域大小由其自身高度、其前面的用户消息高度以及聊天容器的高度共同决定。

![](/images/posts/8d35d6473464.png)

![](/images/posts/b0090f3988fc.png)

### 链接到标题实现 useMessageBlankSize

为了实现空白区域大小，我们从助手消息中一个名为 `useMessageBlankSize` 的钩子开始：

```
1function AssistantMessage({ message, index }) {2  // ...样式逻辑3  const { onLayout, ref } = useMessageBlankSize({ index })4  return (5    <Animated.View ref={ref} onLayout={onLayout}>6      <AssistantMessageContent message={message} />7    </Animated.View>8  )9}
```

`useMessageBlankSize` 负责以下逻辑：

1.  同步测量助手消息
2.  测量其前面的用户消息
3.  计算助手消息下方空白区域大小的最小距离
4.  跟踪键盘打开或关闭时空白区域大小应该是多少
5.  在根上下文提供者处设置 `blankSize` 共享值

同步测量助手消息

测量其前面的用户消息

计算助手消息下方空白区域大小的最小距离

跟踪键盘打开或关闭时空白区域大小应该是多少

在根上下文提供者处设置 `blankSize` 共享值

最后，我们消费 `blankSize` 并将其传递给 `ScrollView` 的 `contentInset`：

```
1export function MessagesList(props) {2  const { blankSize, composerHeight, keyboardHeight } = useMessageListContext()3
4  const animatedProps = useAnimatedProps(() => {5    return {6      contentInset: {7        bottom: blankSize.get() + composerHeight.get() + keyboardHeight.get(),8      },9    }10  })11
12  return <AnimatedLegendList {...props} animatedProps={animatedProps} />13}
```

将 blankSize 传递给 contentInset

Reanimated 的 `useAnimatedProps` 允许我们在每一帧更新 UI 线程上的属性，而不会触发重新渲染。`contentInset` 带来了出色的性能，效果远优于之前的所有尝试。

## 驯服键盘

构建良好的聊天体验关键在于优雅的键盘处理。在 React Native 中实现原生般的感受在这一领域是繁琐且具有挑战性的。当 `v0` iOS 处于公开测试阶段时，苹果发布了 iOS 26。每次新的 iOS 测试版发布，我们的聊天功能似乎都会完全崩溃。每个 iOS 版本都变成了一场猫鼠游戏，需要重现微小的差异和抖动。

幸运的是，`react-native-keyboard-controller` 的维护者 Kiryl 帮助我们解决了这些问题，他经常在苹果发布新测试版的 24 小时内更新该库。

### 构建 `useKeyboardAwareMessageList`

我们使用了 React Native Keyboard Controller 提供的许多钩子，来构建我们专为 `v0` 聊天量身定制的键盘管理系统。

`useKeyboardAwareMessageList` 是我们自定义的 React 钩子，负责处理我们所有的键盘处理逻辑。我们将其与聊天列表一起渲染，它抽象了所有我们需要让键盘感觉恰到好处的细节。

```
1function MessagesList() {2  useKeyboardAwareMessageList()3  4  // ...消息列表的其余部分5}
```

使用 useKeyboardAwareMessageList

虽然使用它只需一行代码，但其内部实现大约有 1000 行代码，并包含许多单元测试。`useKeyboardAwareMessageList` 主要依赖于上游的 `useKeyboardHandler`，处理诸如 `onStart`、`onEnd` 和 `onInteractive` 等事件，并结合了许多 Reanimated 的 `useAnimatedReaction` 调用来在特定边缘情况下重试事件。

`useKeyboardAwareMessageList` 还处理了 iOS 中的许多奇怪行为。例如，如果在键盘打开时将应用切换到后台，然后重新聚焦该应用，iOS 会莫名其妙地触发三次键盘 `onEnd` 事件。由于我们在事件触发时依赖于命令式行为，因此我们想出了一些技巧来去重重复事件并跟踪应用状态变化。

`useKeyboardAwareMessageList` 实现了以下功能：

1.  当键盘打开时，缩小 `blankSize`
2.  如果你滚动到聊天末尾，并且没有空白区域，则在键盘打开时将内容上移
3.  如果你向上滚动得足够高，并且没有空白区域，则在内容上方显示键盘，而不移动内容本身
4.  当用户通过滚动视图或文本输入交互式地关闭键盘时，平滑地将其向下拖动
5.  如果你滚动到聊天末尾，并且空白区域大于键盘高度，内容应保持原位
6.  如果你滚动到聊天末尾且空白区域大于零，但当键盘打开时它应该为零，则将内容上移，使其位于键盘上方

当键盘打开时，缩小 `blankSize`

如果你滚动到聊天末尾，并且没有空白区域，则在键盘打开时将内容上移

如果你向上滚动得足够高，并且没有空白区域，则在内容上方显示键盘，而不移动内容本身

当用户通过滚动视图或文本输入交互式地关闭键盘时，平滑地将其向下拖动

如果你滚动到聊天末尾，并且空白区域大于键盘高度，内容应保持原位

如果你滚动到聊天末尾且空白区域大于零，但当键盘打开时它应该为零，则将内容上移，使其位于键盘上方

没有单一的技巧能让这一切正常工作。我们花费了数十个小时使用该应用，注意到不完美之处，追踪问题，并重写逻辑，直到感觉正确为止。

## 初始滚动至末尾

当你打开一个现有聊天时，`v0` 会从聊天末尾开始滚动。这类似于在 React Native 的 `FlatList` 上使用 `inverted` 属性，这在自下而上的聊天界面中很常见。

然而，我们决定不使用 `inverted`，因为它感觉与 AI 聊天不兼容，在 AI 聊天中，消息每秒会多次流式传入。我们选择不在助手消息流式传入时自动滚动。相反，我们让内容在键盘下方自然填充，同时提供一个按钮可以滚动到末尾。这与 ChatGPT 的 iOS 应用行为一致。

也就是说，我们希望在首次打开现有聊天时获得类似反转列表的体验。为了实现这一点，我们在聊天首次变为可见时调用 `scrollToEnd`。

由于动态消息高度和空白区域的复杂组合，我们必须多次调用 `scrollToEnd`。如果不这样做，我们的列表要么无法正确滚动，要么滚动得太晚。一旦内容滚动完毕，我们就调用 `hasScrolledToEnd.set(true)` 来淡入聊天界面。

```
1import { scheduleOnRN } from 'react-native-worklets'2
3export function useInitialScrollToEnd(blankSize, scrollToEnd, hasMessages) {4  const hasStartedScrolledToEnd = useSharedValue(false)5  const hasScrolledToEnd = useSharedValue(false)6  const scrollToEndJS = useLatestCallback(() => {7    scrollToEnd({ animated: false })8    // 再调用一次以防万一，因为列表可能尚未完全布局完成9    requestAnimationFrame(() => {10      scrollToEnd({ animated: false })11
12      // 再调用一次以防万一13      setTimeout(() => {14        scrollToEnd({ animated: false })15
16        // 再来一次！17        requestAnimationFrame(() => {18          hasScrolledToEnd.set(true)19        })20      }, 16)21    })22  })23
24  useAnimatedReaction(25    () => {26      if (hasStartedScrolledToEnd.get() || !hasMessages) {27        return false28      }29      return blankSize.get() > 030    },31    (shouldScroll) => {32      if (shouldScroll) {33        hasStartedScrolledToEnd.set(true)34        scheduleOnRN(scrollToEndJS)35      }36    }37  )38
39  return hasScrolledToEnd40}
```

多次调用 scrollToEnd 以处理动态高度

## 浮动输入框

受 iOS 26 中 iMessage 底部工具栏的启发，我们构建了一个具有渐进式模糊效果的液态玻璃输入框。

我们使用 `@callstack/liquid-glass` 来添加交互式液态玻璃效果。通过将玻璃视图包裹在 `LiquidGlassContainerView` 中，我们自动获得了视图变形效果。

```
1<LiquidGlassContainerView spacing={8}>2  <LiquidGlassView interactive>...</LiquidGlassView>3  <LiquidGlassView interactive>...</LiquidGlassView>4</LiquidGlassContainerView>
```

为输入框添加液态玻璃效果

### 使其浮动

添加液态玻璃效果后，下一步是使其浮动在聊天内容之上。

为了使输入框浮动在可滚动内容之上，我们采取了以下步骤：

1.  为输入框添加 `position: absolute; bottom: 0`
2.  将输入框包裹在来自 `react-native-keyboard-controller` 的 `KeyboardStickyView` 中
3.  同步测量输入框的高度，并使用共享值将其存储在上下文中
4.  将 `composerHeight.get()` 添加到我们 ScrollView 的原生 `contentInset.bottom` 属性中

为输入框添加 `position: absolute; bottom: 0`

将输入框包裹在来自 `react-native-keyboard-controller` 的 `KeyboardStickyView` 中

同步测量输入框的高度，并使用共享值将其存储在上下文中

将 `composerHeight.get()` 添加到我们 ScrollView 的原生 `contentInset.bottom` 属性中

```
1function Composer() {2  const { composerHeight } = useComposerHeightContext()3  const { onLayout, ref } = useSyncLayoutHandler((layout) => {4    composerHeight.set(layout.height)5  })6  const insets = useInsets()7
8  return (9    <KeyboardStickyView10      style={{ position: 'absolute', bottom: 0, left: 0, right: 0 }}11      offset={{ closed: -insets.bottom, opened: -8 }}12    >13      <View14        ref={ref}15        onLayout={onLayout}16      >17        {/* ... */}18      </View>19    </KeyboardStickyView>20  )21}
```

使用 KeyboardStickyView 定位输入框

然而，这还不够。我们仍然缺少一个关键行为。

当你输入时，文本输入框的高度可能会增加。当你输入新行时，我们希望模拟在常规的、非绝对定位的输入框中打字的体验。我们必须找到一种方法来向上移动聊天消息，但前提是你已经滚动到了聊天的末尾。

在下面的视频中，你可以看到这两种情况。在视频开始时，由于聊天已滚动到底部，内容会随着新行的输入而上移。但是，在聊天中向上滚动后，输入新行将不会移动内容。

### 链接到标题useScrollWhenComposerSizeUpdates

引入 `useScrollWhenComposerSizeUpdates`。这个钩子监听输入框的高度，并在需要时自动滚动到底部。要使用它，我们只需在 `MessagesList` 中调用它：

```
1export function MessagesList() {2  useScrollWhenComposerSizeUpdates()3 4  // ...message list code  5}
```

使用 useScrollWhenComposerSizeUpdates

首先，它使用 `useAnimatedReaction` 设置一个效果来跟踪输入框高度的变化。

接下来，我们调用 `autoscrollToEnd`。只要你足够接近可滚动区域的底部，我们就会自动滚动到聊天的末尾。如果没有这个，在输入框中输入新行会与可滚动区域的底部重叠。

`useScrollWhenComposerSizeUpdates` 让我们有条件地模拟一个非绝对定位视图的体验。

```
1export function useScrollWhenComposerSizeUpdates() {2  const { listRef, scrollToEnd } = useMessageListContext()3  const { composerHeight } = useComposerHeightContext()4
5  const autoscrollToEnd = () => {6    const list = listRef.current7    if (!list) {8      return9    }10
11    const state = list.getState()12    const distanceFromEnd =13      state.contentLength - state.scroll - state.scrollLength14
15    if (distanceFromEnd < 0) {16      scrollToEnd({ animated: false })17      // wait a frame for LegendList to update, and fire it again18      setTimeout(() => {19        scrollToEnd({ animated: false })20      }, 16)21    }22  }23
24  useAnimatedReaction(25    () => composerHeight.get(),26    (height, prevHeight) => {27      if (height > 0 && height !== prevHeight) {28        scheduleOnRN(autoscrollToEnd)29      }30    }31  )32}
```

当输入框增长时滚动到底部

正如我们在前面的代码中看到的，不幸的是，我们依赖了许多 `setTimeout` 和 `requestAnimationFrame` 调用来执行 `scrollToEnd`。这段代码无疑会让人感到惊讶，但这是我们设法让滚动到底部正常工作的唯一方法。我们正在积极与 LegendList 的维护者 Jay 合作，以构建一种更可靠的方法。

### 链接到标题让它感觉原生

React Native 内置的 `TextInput` 在原生聊天应用中显得格格不入。

默认情况下，当你设置 `multiline={true}` 时，`TextInput` 会显示难看的滚动指示器，这与大多数聊天应用不一致。在输入框上向上或向下滑动会使其内部内容弹跳，即使你还没有输入任何文本。此外，该输入框不支持交互式键盘关闭。

为了解决这些问题，我们在原生代码中对 `RCTUITextView` 应用了一个补丁。这个补丁禁用了滚动指示器，移除了弹跳效果，并启用了交互式键盘关闭。

我们的补丁还增加了向上滑动以聚焦输入框的支持。在观察到测试者沮丧地向上滑动期望键盘打开后，我们意识到需要这个功能。

```
1diff --git a/Libraries/Text/TextInput/Multiline/RCTUITextView.mm b/Libraries/Text/TextInput/Multiline/RCTUITextView.mm2index 6e9c3841cee19632eaa59ae2dbd541a85ce7cabf..e3f920acbc2bb074582ed2b531ddd90e2017d59c 1006443--- a/Libraries/Text/TextInput/Multiline/RCTUITextView.mm4+++ b/Libraries/Text/TextInput/Multiline/RCTUITextView.mm5@@ -55,6 +55,16 @@ - (instancetype)initWithFrame:(CGRect)frame6     self.textContainer.lineFragmentPadding = 0;7     self.scrollsToTop = NO;8     self.scrollEnabled = YES;9+10+    // Fix bouncing, scroll indicator, and keyboard mode gesture11+    self.showsVerticalScrollIndicator = NO;12+    self.showsHorizontalScrollIndicator = NO;13+    self.bounces = NO;14+    self.alwaysBounceVertical = NO;15+    self.alwaysBounceHorizontal = NO;16+    self.keyboardDismissMode = UIScrollViewKeyboardDismissModeInteractive;17+    [self.panGestureRecognizer addTarget:self action:@selector(_handlePanToFocus:)];18+19     _initialValueLeadingBarButtonGroups = nil;20     _initialValueTrailingBarButtonGroups = nil;21   }22@@ -62,6 +72,18 @@ - (instancetype)initWithFrame:(CGRect)frame23   return self;24 }25 26+- (void)_handlePanToFocus:(UIPanGestureRecognizer *)g27+{28+    if (self.isFirstResponder) { return; }29+    if (g.state != UIGestureRecognizerStateBegan) { return; }30+    CGPoint v = [g velocityInView:self];31+    CGPoint t = [g translationInView:self];32+    // Add pan gesture to focus the keyboard33+    if (v.y < -250.0 && !self.isFirstResponder) {34+        [self becomeFirstResponder];35+    }36+}37+38 - (void)setDelegate:(id<UITextViewDelegate>)delegate39 {40   // Delegate is set inside `[RCTBackedTextViewDelegateAdapter initWithTextView]` and
```

虽然跨 React Native 更新维护一个补丁并不理想，但这是我们找到的最实用的解决方案。我们更希望有一个官方的 API 来扩展原生视图而无需打补丁，如果社区有兴趣，我们计划将这个补丁贡献给 React Native 核心。

## 链接到标题粘贴图片

为了支持在文本输入框中粘贴图片和文件，我们使用了一个 Expo 模块来监听原生 `UIPasteboard` 的粘贴事件。

如果你粘贴足够长的文本，`onPaste` 会自动将粘贴的内容转换为 `.txt` 文件附件。

```
1<TextInputWrapper onPaste={pasted => ...}>2  <TextInput />3</TextInputWrapper>
```

包装 TextInput 以处理粘贴事件

由于很难在原生代码中扩展现有的 `TextInput`，我们使用了一个 `TextInputWrapper` 组件来包装 `TextInput`，并在 Swift 中遍历其 `subviews`。关于创建原生包装组件的更深入示例，你可以观看我 2024 年的演讲《不要害怕构建原生库》。

## 链接到标题流式内容的淡入效果

当 AI 助手消息流式传入时，它需要感觉流畅。为了实现这一点，我们创建了两个组件：

1. `<FadeInStaggeredIfStreaming />`
2. `<TextFadeInStaggeredIfStreaming />`

<FadeInStaggeredIfStreaming />

<TextFadeInStaggeredIfStreaming />

只要一个元素被这些组件之一包裹，其子元素就会以交错的动画平滑地淡入。

```
1const mdxComponents = {2  a: function A(props) {3    return (4      <Elements.A {...props}>5        <TextFadeInStaggeredIfStreaming>6          {props.children}7        </TextFadeInStaggeredIfStreaming>8      </Elements.A>9    )10  },11  // ...other components12}
```

在 MDX 组件中使用 TextFadeInStaggeredIfStreaming

在底层，这些组件渲染了一个 `FadeInStaggered` 的变体，它处理状态管理：

```
1const useIsAnimatedInPool = createUsePool()2
3function FadeInStaggered({ children }) {4  const { isActive, evict } = useIsAnimatedInPool()5  return isActive ? <FadeIn onFadedIn={evict}>{children}</FadeIn> : children6}
```

使用池管理动画状态

`useIsAnimatedInPool` 是一个位于 React 外部的自定义状态管理器，它允许有限数量的有序元素同时被渲染。元素在挂载时请求加入池，`isActive` 则指示它们是否应渲染一个动画节点。

在 `onFadedIn` 回调触发后，我们将元素从池中移除，直接渲染其子元素而无需动画包装器。这有助于我们限制同时处于活动状态的动画节点数量。

最后，`FadeIn` 会渲染一个交错动画，元素间有 32 毫秒的延迟。交错动画按计划运行，每次批量动画处理 2 个项目。当交错项目的队列长度超过 10 时，我们会根据队列大小增加批量处理的项目数量。

```
1const useStaggeredAnimation = createUseStaggered(32)2
3function FadeIn({ children, onFadedIn, Component }) {4  const opacity = useSharedValue(0)5
6  const startAnimation = () => {7    opacity.set(withTiming(1, { duration: 500 }))8    setTimeout(onFadedIn, 500)9  }10
11  useStaggeredAnimation(startAnimation)12
13  return <Component style={{ opacity }}>{children}</Component>14}
```

交错淡入动画

`TextFadeInStaggeredIfStreaming` 采用了类似的策略。我们首先将单词分割成独立的文本节点，然后为文本元素创建一个上限为 4 的唯一池。这确保一次最多只有 4 个单词会淡入。

```
1const useShouldTextFadePool = createUsePool(4)2
3function TextFadeInStaggeredIfStreaming(props) {4  const { isStreaming } = use(MessageContext)5  const { isActive } = useShouldTextFadePool()6
7  const [shouldFade] = useState(isActive && isStreaming)8
9  let { children } = props10  if (shouldFade && children) {11    if (Array.isArray(children)) {12      children = Children.map(children, (child, i) =>13        typeof child === 'string' ? <AnimatedFadeInText key={i} text={child} /> : child,14      )15    } else if (typeof children === 'string') {16      children = <AnimatedFadeInText text={children} />17    }18  }19
20  return children21}22
23function AnimatedFadeInText({ text }) {24  const chunks = text.split(' ')25
26  return chunks.map((chunk, i) => <TextFadeInStaggered key={i} text={chunk + ' '} />)27}28
29function TextFadeInStaggered({ text }) {30  const { isActive, evict } = useIsAnimatedInPool()31  return isActive ? <FadeIn onFadedIn={evict}>{text}</FadeIn> : text32}
```

分割文本并限制并发动画

我们采用这种方法遇到的一个问题是，它严重依赖于在**挂载时**触发动画。因此，如果你发送一条消息，转到另一个聊天，然后在消息发送完成之前回到原始聊天，该消息会重新挂载并再次播放动画。

为了缓解这个问题，我们实现了一个系统，用于跟踪你在不同聊天中已经看过哪些内容的动画。该实现在树中消息的顶部附近使用了 `DisableFadeProvider`。我们在根淡入组件中使用它，以便在需要时避免影响池。

```
1function TextFadeInStaggeredIfStreaming(props) {2  const { isStreaming } = use(MessageContext)3  const { isActive } = useShouldTextFadePool()4  const isFadeDisabled = useDisableFadeContext()5
6  const [shouldFade] = useState(!isFadeDisabled && isActive && isStreaming)7  8  if (shouldFade) // 在这里我们渲染 TextFadeIn...9  10  return props.children11}
```

对已查看内容禁用淡入效果

虽然以非响应式的方式显式依赖 `useState` 的初始值可能看起来不太寻常，但这让我们能够根据元素的挂载顺序可靠地跟踪元素及其动画状态。

## 在 Web 和原生平台之间共享代码

当我们开始构建 v0 iOS 应用时，一个自然而然的问题出现了：我们应该在 Web 和原生平台之间共享多少代码？

考虑到 v0 Web 单体仓库的成熟度，我们决定共享类型和辅助函数，但不共享 UI 或状态管理。我们还共同努力将业务逻辑从客户端迁移到服务器，让 v0 移动应用成为 API 之上的一个薄包装层。

### 构建共享 API

在一个成熟的 Next.js 应用和一个新的移动应用之间共享后端 API 路由带来了挑战。v0 Web 应用由 React 服务器组件和服务器操作驱动，而移动应用的功能更像一个单页 React 应用。

为了解决这个问题，我们使用一个手写的后端框架构建了一个 API 层。我们的框架通过要求使用 `Zod` 指定输入和输出类型来强制执行运行时类型安全。

定义路由后，我们根据每个路由的 Zod 类型生成一个 `openapi.json` 文件。移动应用使用 `Hey API` 来消费 OpenAPI 规范，它会生成与 `Tanstack Query` 一起使用的辅助函数。

```
1import { termsFindOptions } from '@/api' // 此文件夹是生成的2import { useQuery } from '@tanstack/react-query'3
4export function useTermsQuery({ after }) {5  return useQuery(termsFindOptions({ after }))6}
```

使用 Tanstack Query 生成的 API 辅助函数

这项工作促成了 v0 Platform API 的开发。我们希望为我们自己的原生客户端构建理想的 API，并最终决定向所有人开放该 API。得益于这种方法，v0 移动应用使用了与 v0 的 Platform API 客户相同的路由和逻辑。

在每次提交时，我们都会运行测试，以确保对 OpenAPI 规范的更改与移动应用兼容。

未来，我们希望通过在 Platform API 之上使用类型级别的 RPC 包装器来完全消除代码生成步骤。

## 样式

v0 使用 `react-native-unistyles` 来处理样式和主题。我在 React Native 方面的经验告诉我，要谨慎对待在渲染过程中完成的任何工作。与我们评估过的其他样式库不同，Unistyles 提供了全面的主题功能，而无需重新渲染组件或访问 React Context。

## 原生菜单

除了使用 Unistyles 处理主题和样式外，我们没有使用基于 JS 的组件库。相反，我们尽可能依赖原生元素。

对于菜单，我们使用了 `Zeego`，它在底层依赖 `react-native-ios-context-menu` 来渲染原生 `UIMenu`。当你使用 Xcode 26 构建时，Zeego 会自动渲染 Liquid Glass 菜单。

## 原生警告

在 iOS 26 上，React Native 应用遇到了 `Alert` 弹窗渲染到屏幕外的问题。我们在自己的应用以及许多流行的 React Native 应用中重现了这个问题。我们在本地进行了修补，并与 Callstack 和 Meta 的开发人员合作，在 React Native 中**上游修复了此问题**。

## 原生底部表单

对于底部表单，我们使用了内置的 React Native 模态框，并设置 `presentationStyle="formSheet"`。然而，这带来了一些缺点，我们通过补丁解决了这些问题。

### 模态框拖动问题

首先，当向下拖动表单时，它会暂时冻结在原位，然后才正确关闭。为了解决这个问题，我们在本地修补了 React Native。我们与 Callstack 合作，**将我们的补丁上游合并到** React Native 中，现在它已在 0.82 版本中生效。

### 修复 Yoga 闪烁问题

如果你将一个带有 `flex: 1` 的 `View` 放在一个有背景色的模态框内，然后上下拖动模态框，视图的底部会剧烈闪烁。

为了解决这个问题，我们在本地修补了 React Native，以支持在 Yoga 中对模态框进行同步更新。我们与来自 Callstack、Expo 和 Meta 的开发人员合作，将这一更改上游合并到 React Native 核心中。**现在它已在** React Native 0.82 版本中生效。

## 展望未来

在使用 React Native 和 Expo 构建了我们的第一个应用之后，我们不再回头。如果你还没有尝试过 v0 for iOS，**请下载它**，并通过 App Store 评价告诉我们你的想法。

我们正在招聘开发人员加入 Vercel 移动团队。如果这类工作让你感到兴奋，我们很乐意**收到你的来信**。

在Vercel，我们致力于打造最高水准的雄心勃勃的产品。我们希望让网页和原生开发者能够轻松实现同样的目标，并计划将我们的研究成果开源。如果您希望参与AI聊天应用开源库的测试，请通过X联系我们。我们期待与社区合作，持续改进React Native。

---

> 本文由AI自动翻译，原文链接：[How we built the v0 iOS app - Vercel](https://vercel.com/blog/how-we-built-the-v0-ios-app)
> 
> 翻译时间：2026-01-07 13:05
