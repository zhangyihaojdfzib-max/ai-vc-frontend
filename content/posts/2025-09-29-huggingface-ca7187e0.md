---
title: VibeGame：探索AI氛围式编码游戏的挑战与解决方案
title_original: 'VibeGame: Exploring Vibe Coding Games'
date: '2025-09-29'
source: Hugging Face Blog
source_url: https://huggingface.co/blog/vibegame
author: ''
summary: 本文探讨了使用AI进行“氛围式编码”开发游戏时遇到的挑战，特别是项目规模扩大后上下文管理困难的问题。作者尝试了Roblox、Unity和Web技术栈三种方案，发现Web技术栈因开源透明、AI训练数据充足而表现最佳，但需要从底层构建引擎。为此，作者开发了轻量级上下文管理工具Shallot，并提出了VibeGame解决方案，旨在平衡抽象层级与AI可理解性，为AI辅助游戏开发提供新思路。
categories:
- AI产品
tags:
- 氛围式编码
- AI编程
- 游戏开发
- 上下文管理
- Web技术栈
draft: false
translated_at: '2026-01-30T04:05:20.241366'
---

# VibeGame：探索氛围式编码游戏

## 问题所在

人们正尝试用氛围式编码来制作游戏。起初，这种方法似乎奏效。然而，随着项目规模扩大，问题开始显现。为什么会这样？我们能做些什么？

我将探讨这个问题、我的解决方案以及未来的方向。

## 什么是“氛围式编码”？

首先，什么是氛围式编码？这个词最初由 Andrej Karpathy 在一篇病毒式传播的推文中提出，定义为“完全沉浸于氛围，拥抱指数级增长，甚至忘记代码的存在”。

然而，此后它被广泛用于描述多种不同的事物，从“在编码时使用AI”到“完全不思考代码”都可以涵盖。在这篇博文中，我将它定义为：使用AI作为一种高级编程语言来构建事物。与其他编程语言类似，理解其底层原理会有所帮助，但并非必需。

按照这种理解，即使不懂代码也能制作游戏，不过掌握基础知识仍然有益。

## 上下文管理

之前我提到“随着项目规模扩大，问题开始显现”。这是因为有证据表明，随着上下文窗口被填满，模型性能会开始下降。这在游戏开发中尤其明显，因为上下文可能迅速变得非常庞大。

为了解决这个问题，存在许多个人化的临时解决方案，例如直接在项目文件中编写针对LLM的特定上下文，或者更全面的方案，如用于大规模上下文管理的Claude Code Development Kit。

我未能找到一个轻量级、易于使用且不依赖大量领域知识的解决方案。因此，我创建了一个：🧅Shallot，一个为Claude Code设计的简单、轻量、无预设偏好的上下文管理系统。它依赖两个基本命令：

1. `/peel [提示词]` 在对话开始时加载上下文
2. `/nourish` 在对话结束时更新上下文

根据经验，这很有效。然而，当项目保持精简和良好组织时效果最佳，这样所有相关上下文都能轻松放入模型的上下文窗口。虽然这里使用了Claude Code，但同样的原则也适用于其他模型。

除了上下文管理工具，平台选择也至关重要。理想的平台应通过高级抽象自然保持项目精简，同时AI模型也能很好地理解它。那么，哪些现有平台最适合氛围式编码？

## 初步探索

我最初尝试了三种不同的氛围式编码游戏方法：Roblox MCP、Unity MCP 和 Web 技术栈。对于每一种，我都尝试使用Claude Code构建一个受《Grass Cutting Incremental》启发的简单增量游戏。

情况如下：

### 尝试一：Roblox MCP

Roblox的官方MCP服务器。这允许AI通过发送命令运行代码来与Roblox Studio交互。

优点：
*   出色的抽象级别，内置游戏机制
*   AI能非常容易地理解语法并将指令转换为代码

缺点：
*   没有文件系统，仅使用代码读取数据，严重限制了上下文管理
*   AI可用的运行时信息非常有限
*   专有的封闭生态系统

Roblox为保持代码库精简和可管理提供了极佳的抽象层，这对氛围式编码来说是完美的。然而，其封闭的生态系统和上下文的缺乏使得它不适合氛围式编码，除非是在Roblox公司内部。

### 尝试二：Unity MCP

Unity的非官方MCP服务器。这允许AI与Unity编辑器交互：读取控制台、管理资源、验证脚本。

优点：
*   完整的文件系统访问权限

缺点：
*   Unity中实现同一功能的方式繁多，且版本间频繁变化，导致AI困惑
*   需要大量领域知识来告诉AI“如何”做，而不是“做什么”
*   AI表现不一致且不可靠
*   专有引擎（尽管比Roblox透明得多）

Unity是一个功能强大的引擎，能力丰富。然而，引擎的复杂性和多变性使得AI难以在没有大量用户领域知识的情况下持续产出良好结果。

### 尝试三：Web技术栈

开放的Web平台，使用three.js进行3D渲染，rapier处理物理，bitecs处理游戏逻辑。

优点：
*   相比游戏引擎，AI熟练度远胜，可能得益于海量的训练数据
*   完整的文件系统访问权限
*   完全开源的技术栈，拥有完全的控制权/透明度

缺点：
*   库的层级相对较低，基本上需要先构建引擎才能构建游戏
*   缺乏高质量3D游戏的生态系统；Web平台倾向于2D游戏和简单的3D体验

这种方法迄今为止AI表现最佳，可能因为训练时可用的Web开发数据量巨大。然而，库的低层级特性意味着我基本上需要先构建一个游戏引擎，然后才能构建游戏本身。这使我们能够在更高的抽象层级上工作，就像我们在Roblox中那样。

尽管需要先构建引擎，但这是唯一一种无需深厚领域知识就能产出有趣结果的方法。

### 对比总结

## 解决方案：VibeGame

经过这些实验，我有了清晰的图景：Web技术栈AI表现优异但层级太低，而Roblox抽象完美但缺乏开放性和上下文管理。

那么，结合两者的优点如何？

介绍VibeGame，一个基于three.js、rapier和bitecs构建的高级声明式游戏引擎，专为AI辅助游戏开发而设计。

### 设计理念

VibeGame的设计基于三个关键决策：

1.  **抽象**：提供高级抽象，内置物理、渲染和常见游戏机制等功能，保持代码库精简和可管理。这借鉴了流行的高级沙盒游戏/游戏“引擎”，如Roblox、Fortnite UEFN和Minecraft。
2.  **语法**：采用类似XML的声明式语法来定义游戏对象及其属性，使AI易于理解和生成代码。这类似于AI模型已经精通的HTML/CSS。
3.  **架构**：采用实体-组件-系统架构以实现可扩展性和灵活性。ECS将数据与行为分离，鼓励项目在增长过程中保持模块化和组织性，有利于氛围式编码和上下文管理。

一个基础的游戏看起来像这样：

```html
<world canvas="#game-canvas" sky="#87ceeb">
  
  <static-part pos="0 -0.5 0" shape="box" size="20 1 20" color="#90ee90"></static-part>

  
  <dynamic-part pos="-2 4 -3" shape="sphere" size="1" color="#ff4500"></dynamic-part>
</world>

<canvas id="game-canvas"></canvas>

<script type="module">
  import * as GAME from 'vibegame';
  GAME.run();
</script>

```

在此JSFiddle或Live Demo中查看实际效果。

这将创建一个包含地面和下落球体的简单场景。玩家、相机和光照会自动创建。所有这些都是模块化的，可以替换。可以根据需要添加任意自定义组件和系统。

引擎附带一个`llms.txt`文件，其中包含专门为AI设计的引擎文档，可包含在其系统提示词或初始上下文中。

## 那么它真的有效吗？

嗯，某种程度上是的。

这是我为了测试使用VibeGame和Claude Code构建一个简单的增量式收集草的游戏而制作的游戏。它运行得非常好，实现核心游戏机制所需的领域知识极少。

![Grass Cutting Game](/images/posts/f754b23bc1a5.gif)

然而，仍然存在一些主要的注意事项：

1. 它非常适合构建游戏引擎所支持的内容，即仅依赖基础物理和渲染的简单平台游戏或游戏。
2. 然而，对于引擎尚未实现的更复杂功能，如交互、物品栏、多人游戏、战斗等，它就显得力不从心。

因此，如果将氛围编程定义为一次性"给我做个游戏"的方式，它是行不通的。然而，如果将其视为一种高级编程语言，它则表现得非常出色，但这要求用户理解引擎的能力与局限。

## 亲自尝试

为了能立即体验，我构建了一个演示，您可以在浏览器中直接使用 VibeGame 配合 Qwen3-Next-80B-A3B-Instruct 开发游戏：[Hugging Face 上的实时演示](https://huggingface.co/spaces/your-demo-link)。

您也可以使用像 Claude Code 这样的前沿模型在本地测试：

```bash
npm create vibegame@latest my-game
cd my-game
npm run dev  

```

然后，将包含的 `llms.txt` 的全部内容粘贴到 `CLAUDE.md` 中，为 AI 提供完整的引擎文档以供参考（或者让您自己的上下文管理系统指向它）。这同样适用于其他模型。

## 下一步是什么？

该引擎目前非常基础，仅支持非常简单的机制（除非从头编写）。然而，初步结果令人鼓舞。

接下来的步骤将是：

1. 充实引擎，加入更多内置机制，使其更接近早期版本的 Roblox 或 UEFN。这包括：
    * 交互
    * 物品栏/物品
    * 多人游戏
    * 带有精选数据库的蒙皮网格/动画
    * 带有精选数据库的音频

2. 改进 AI 引导系统，为初学者提供更好的体验。这包括：
    * 关于引擎能力/局限的清晰信息提示
    * 常见任务的引导式提示词
    * 更多示例和模板
    * 教育资源

同样值得探索的是，氛围编程游戏如何能利用更成熟的引擎。例如，在 Unity 或虚幻引擎之上构建一个高级沙盒游戏编辑器（类似于《堡垒之夜》的虚幻编辑器构建于虚幻引擎之上），可以为 AI 提供一个更可控的工作环境，同时利用成熟引擎的强大功能。

我们也可能会看到主要厂商推出更多内部解决方案。

[关注我](https://twitter.com/your-handle)以了解该领域的最新动态！

链接：

*   [VibeGame](https://vibegame.com)
*   [Hugging Face 演示](https://huggingface.co/spaces/your-demo-link)
*   [示例游戏（使用 VibeGame 制作）](https://example-game.com)
*   [Shallot 上下文管理器](https://shallot-context.com)

---

> 本文由AI自动翻译，原文链接：[VibeGame: Exploring Vibe Coding Games](https://huggingface.co/blog/vibegame)
> 
> 翻译时间：2026-01-30 04:05
